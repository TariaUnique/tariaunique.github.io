<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="TariaUnique">
    <meta name="description" content="#####SSTable磁盘存储的SSTable，划分为多个Block。主要有存储数据的Block,存储索引的Block,以及为了优化查询使用的存储filter数据的block。格式如下

data block
data block按序存储">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TariaUnique</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/matery.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/my.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/post.css">




    



    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TariaUnique</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TariaUnique</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-11-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-07-16
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    24 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>#####SSTable<br>磁盘存储的SSTable，划分为多个Block。主要有存储数据的Block,存储索引的Block,以及为了优化查询使用的存储filter数据的block。<br>格式如下<br><img src="/../images/sstable.jpg"></p>
<ul>
<li>data block<ul>
<li>data block按序存储key&#x2F;value数据。一个data block 大小默认为4kb,其中key&#x2F;value 存储为entry。</li>
<li>为了节省空间，对连续key相同的前缀只存储前缀长度。entry格式为<code>shardkeylen,noshardkeylen,valuelen,key delta, value</code></li>
<li>key&#x2F;value 为变长，为了支持二分查找，同时为了避免第一个key的损坏导致整个block后续key都无法读取，默认每隔16个entry加入一个restart point。restart point 处的entry,完整存储key。在所有entry最后存储restart point 数组，二分查找时先由restart point数组定位到某个offset,然后顺序查找。<br><img src="/../images/block.png"></li>
</ul>
</li>
</ul>
<p><code>class BlockBuilder</code> 用于序列化block</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BlockBuilder &#123;
 public:
  explicit BlockBuilder(const Options* options);


  &#x2F;&#x2F; Reset the contents as if the BlockBuilder was just constructed.
  void Reset();

  &#x2F;&#x2F; REQUIRES: Finish() has not been called since the last call to Reset().
  &#x2F;&#x2F; REQUIRES: key is larger than any previously added key
  void Add(const Slice&amp; key, const Slice&amp; value);

  &#x2F;&#x2F; Finish building the block and return a slice that refers to the
  &#x2F;&#x2F; block contents.  The returned slice will remain valid for the
  &#x2F;&#x2F; lifetime of this builder or until Reset() is called.
  Slice Finish();

  &#x2F;&#x2F; Returns an estimate of the current (uncompressed) size of the block
  &#x2F;&#x2F; we are building.
  size_t CurrentSizeEstimate() const;

  &#x2F;&#x2F; Return true iff no entries have been added since the last Reset()
  bool empty() const &#123; return buffer_.empty(); &#125;

 private:
  const Options* options_;
  std::string buffer_;              &#x2F;&#x2F; Destination buffer
  std::vector&lt;uint32_t&gt; restarts_;  &#x2F;&#x2F; Restart points
  int counter_;                     &#x2F;&#x2F; Number of entries emitted since restart
  bool finished_;                   &#x2F;&#x2F; Has Finish() been called?
  std::string last_key_;
&#125;;

Slice BlockBuilder::Finish() &#123;
  &#x2F;&#x2F; Append restart array
  for (size_t i &#x3D; 0; i &lt; restarts_.size(); i++) &#123;
    PutFixed32(&amp;buffer_, restarts_[i]);
  &#125;
  PutFixed32(&amp;buffer_, restarts_.size());
  finished_ &#x3D; true;
  return Slice(buffer_);
&#125;

void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value) &#123;
  Slice last_key_piece(last_key_);
  assert(!finished_);
  assert(counter_ &lt;&#x3D; options_-&gt;block_restart_interval);
  assert(buffer_.empty()  &#x2F;&#x2F; No values yet?
         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; 0);
  size_t shared &#x3D; 0;
  if (counter_ &lt; options_-&gt;block_restart_interval) &#123;
    &#x2F;&#x2F; See how much sharing to do with previous string
    const size_t min_length &#x3D; std::min(last_key_piece.size(), key.size());
    while ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] &#x3D;&#x3D; key[shared])) &#123;
      shared++;
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; Restart compression
    restarts_.push_back(buffer_.size());
    counter_ &#x3D; 0;
  &#125;
  const size_t non_shared &#x3D; key.size() - shared;

  &#x2F;&#x2F; Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_
  PutVarint32(&amp;buffer_, shared);
  PutVarint32(&amp;buffer_, non_shared);
  PutVarint32(&amp;buffer_, value.size());

  &#x2F;&#x2F; Add string delta to buffer_ followed by value
  buffer_.append(key.data() + shared, non_shared);
  buffer_.append(value.data(), value.size());

  &#x2F;&#x2F; Update state
  last_key_.resize(shared);
  last_key_.append(key.data() + shared, non_shared);
  assert(Slice(last_key_) &#x3D;&#x3D; key);
  counter_++;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码很直观，就不多说了。<br>block_restart_interval 可配置</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Number of keys between restart points for delta encoding of keys.
&#x2F;&#x2F; This parameter can be changed dynamically.  Most clients should
&#x2F;&#x2F; leave this parameter alone.
int block_restart_interval &#x3D; 16;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>block size 可配置</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Approximate size of user data packed per block.  Note that the
&#x2F;&#x2F; block size specified here corresponds to uncompressed data.  The
&#x2F;&#x2F; actual size of the unit read from disk may be smaller if
&#x2F;&#x2F; compression is enabled.  This parameter can be changed dynamically.
size_t block_size &#x3D; 4 * 1024;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>class Block</code>封装了Block数据的解析操作。其data_所指向的可能为堆内存也可能为mmap映射的内存。如果为堆内存，则可被缓存，并且析构时应该delete掉。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Block &#123;
 public:
  &#x2F;&#x2F; Initialize the block with the specified contents.
  explicit Block(const BlockContents&amp; contents);

  ~Block();

  size_t size() const &#123; return size_; &#125;
  Iterator* NewIterator(const Comparator* comparator);

 private:
  class Iter;

  uint32_t NumRestarts() const;

  const char* data_;
  size_t size_;
  uint32_t restart_offset_;  &#x2F;&#x2F; Offset in data_ of restart array
  bool owned_;               &#x2F;&#x2F; Block owns data_[]
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>struct BlockContents</code>为从文件读出的Block数据。文件的读取操作可能为文件io,也可能为mmap文件映射。<br>如果为mmap文件映射，则data指向的内存为映射的内存，如果为文件io，则指向堆内存。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct BlockContents &#123;
  Slice data;           &#x2F;&#x2F; Actual contents of data
  bool cachable;        &#x2F;&#x2F; True iff data can be cached
  bool heap_allocated;  &#x2F;&#x2F; True iff caller should delete[] data.data()
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>读取操作由BlockHandle 设置读取的offset和偏移大小。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BlockHandle &#123;
 public:
&#x2F;&#x2F;......
 private:
  uint64_t offset_;
  uint64_t size_;
&#125;;


Status ReadBlock(RandomAccessFile* file, const ReadOptions&amp; options,
                 const BlockHandle&amp; handle, BlockContents* result) &#123;
  result-&gt;data &#x3D; Slice();
  result-&gt;cachable &#x3D; false;
  result-&gt;heap_allocated &#x3D; false;

  &#x2F;&#x2F; Read the block contents as well as the type&#x2F;crc footer.
  &#x2F;&#x2F; See table_builder.cc for the code that built this structure.
  size_t n &#x3D; static_cast&lt;size_t&gt;(handle.size());
  char* buf &#x3D; new char[n + kBlockTrailerSize];
  Slice contents;
  Status s &#x3D; file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);
  if (!s.ok()) &#123;
    delete[] buf;
    return s;
  &#125;
  if (contents.size() !&#x3D; n + kBlockTrailerSize) &#123;
    delete[] buf;
    return Status::Corruption(&quot;truncated block read&quot;);
  &#125;

  &#x2F;&#x2F; Check the crc of the type and the block contents
  const char* data &#x3D; contents.data();  &#x2F;&#x2F; Pointer to where Read put the data
  if (options.verify_checksums) &#123;
    const uint32_t crc &#x3D; crc32c::Unmask(DecodeFixed32(data + n + 1));
    const uint32_t actual &#x3D; crc32c::Value(data, n + 1);
    if (actual !&#x3D; crc) &#123;
      delete[] buf;
      s &#x3D; Status::Corruption(&quot;block checksum mismatch&quot;);
      return s;
    &#125;
  &#125;

  switch (data[n]) &#123;
    case kNoCompression:
      if (data !&#x3D; buf) &#123;
        &#x2F;&#x2F; File implementation gave us pointer to some other data.
        &#x2F;&#x2F; Use it directly under the assumption that it will be live
        &#x2F;&#x2F; while the file is open.
        delete[] buf;
        result-&gt;data &#x3D; Slice(data, n);
        result-&gt;heap_allocated &#x3D; false;
        result-&gt;cachable &#x3D; false;  &#x2F;&#x2F; Do not double-cache
      &#125; else &#123;
        result-&gt;data &#x3D; Slice(buf, n);
        result-&gt;heap_allocated &#x3D; true;
        result-&gt;cachable &#x3D; true;
      &#125;

      &#x2F;&#x2F; Ok
      break;
    case kSnappyCompression: &#123;
      size_t ulength &#x3D; 0;
      if (!port::Snappy_GetUncompressedLength(data, n, &amp;ulength)) &#123;
        delete[] buf;
        return Status::Corruption(&quot;corrupted compressed block contents&quot;);
      &#125;
      char* ubuf &#x3D; new char[ulength];
      if (!port::Snappy_Uncompress(data, n, ubuf)) &#123;
        delete[] buf;
        delete[] ubuf;
        return Status::Corruption(&quot;corrupted compressed block contents&quot;);
      &#125;
      delete[] buf;
      result-&gt;data &#x3D; Slice(ubuf, ulength);
      result-&gt;heap_allocated &#x3D; true;
      result-&gt;cachable &#x3D; true;
      break;
    &#125;
    default:
      delete[] buf;
      return Status::Corruption(&quot;bad block type&quot;);
  &#125;

  return Status::OK();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后<code>class Block::Iter</code> 封装了Block中Entry的查找以及遍历操作。比较简单直接。</p>
<p><code>class Block</code> 以及<code>class BlockBuilder</code> 适用于DataBlock, IndexBlock的序列化和反序列化。<br>对于DataBlock,其中key为InternalKey,Value为用户存入的Value。对于IndexBlock,分为DataIndexBlock以及MetaIndexBlock。<br>DataIndexBlock中的key&gt;&#x3D;所指向的Block的最大key。Value为Block在sstable中的偏移及大小，即为BlockHandle。对于MetaIndexBlock,key只有filter Block的key,value为filter Block 的BlockHandle。<br>配置参数中<code>block_size</code> 以及<code>block_restart_interval</code>只对DataBlock有效。<br>对于IndexBlock,所有索引存储在一个Block中，不限制大小。同时block_restart_interval为1。即sharedkeylen 字段为0，key为完整的key。</p>
<p>######Filter Block<br>leveldb 提供的filter策略是使用bloom filter。filter block 在metaindexblock中对应的key为<br>filter策略的名字。用户也可以实现自己的策略，然后传入option即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">  if (r-&gt;filter_block !&#x3D; nullptr) &#123;
    &#x2F;&#x2F; Add mapping from &quot;filter.Name&quot; to location of filter data
    std::string key &#x3D; &quot;filter.&quot;;
    key.append(r-&gt;options.filter_policy-&gt;Name());
    std::string handle_encoding;
    filter_block_handle.EncodeTo(&amp;handle_encoding);
    meta_index_block.Add(key, handle_encoding);
  &#125;
  
&#x2F;&#x2F; If non-null, use the specified filter policy to reduce disk reads.
&#x2F;&#x2F; Many applications will benefit from passing the result of
&#x2F;&#x2F; NewBloomFilterPolicy() here.
const FilterPolicy* filter_policy &#x3D; nullptr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><code>class FilterBlockBuilder</code>用于创建filter block。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A FilterBlockBuilder is used to construct all of the filters for a
&#x2F;&#x2F; particular Table.  It generates a single string which is stored as
&#x2F;&#x2F; a special block in the Table.
&#x2F;&#x2F;
&#x2F;&#x2F; The sequence of calls to FilterBlockBuilder must match the regexp:
&#x2F;&#x2F;      (StartBlock AddKey*)* Finish
class FilterBlockBuilder &#123;
 public:
  explicit FilterBlockBuilder(const FilterPolicy*);
  void StartBlock(uint64_t block_offset);
  void AddKey(const Slice&amp; key);
  Slice Finish();

 private:
  void GenerateFilter();

  const FilterPolicy* policy_;
  std::string keys_;             &#x2F;&#x2F; Flattened key contents
  std::vector&lt;size_t&gt; start_;    &#x2F;&#x2F; Starting index in keys_ of each key
  std::string result_;           &#x2F;&#x2F; Filter data computed so far
  std::vector&lt;Slice&gt; tmp_keys_;  &#x2F;&#x2F; policy_-&gt;CreateFilter() argument
  std::vector&lt;uint32_t&gt; filter_offsets_;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>StartBlock</code>根据 DataBlock偏移量&#x2F;2kb 计算应该产生第几个filter string。<br><code>AddKey</code> 记录当前block中的keys。<br><code>Finish</code> 根据记录的keys生成filter string。<br>这种设计跟DataBlock大小解耦，查找时输入任意一个偏移量都能找到该偏移量所在的索引的下标。但需要保证输入的偏移量是严格递增的，keys在偏移量之后。<br>还是直接贴代码比较直观</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static const size_t kFilterBaseLg &#x3D; 11;
static const size_t kFilterBase &#x3D; 1 &lt;&lt; kFilterBaseLg;

void FilterBlockBuilder::StartBlock(uint64_t block_offset) &#123;
  uint64_t filter_index &#x3D; (block_offset &#x2F; kFilterBase);
  assert(filter_index &gt;&#x3D; filter_offsets_.size());
  while (filter_index &gt; filter_offsets_.size()) &#123;
    GenerateFilter();
  &#125;
&#125;

void FilterBlockBuilder::AddKey(const Slice&amp; key) &#123;
  Slice k &#x3D; key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
&#125;

Slice FilterBlockBuilder::Finish() &#123;
  if (!start_.empty()) &#123;
    GenerateFilter();
  &#125;

  &#x2F;&#x2F; Append array of per-filter offsets
  const uint32_t array_offset &#x3D; result_.size();
  for (size_t i &#x3D; 0; i &lt; filter_offsets_.size(); i++) &#123;
    PutFixed32(&amp;result_, filter_offsets_[i]);
  &#125;

  PutFixed32(&amp;result_, array_offset);
  result_.push_back(kFilterBaseLg);  &#x2F;&#x2F; Save encoding parameter in result
  return Slice(result_);
&#125;

void FilterBlockBuilder::GenerateFilter() &#123;
  const size_t num_keys &#x3D; start_.size();
  if (num_keys &#x3D;&#x3D; 0) &#123;
    &#x2F;&#x2F; Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  &#125;

  &#x2F;&#x2F; Make list of keys from flattened key structure
  start_.push_back(keys_.size());  &#x2F;&#x2F; Simplify length computation
  tmp_keys_.resize(num_keys);
  for (size_t i &#x3D; 0; i &lt; num_keys; i++) &#123;
    const char* base &#x3D; keys_.data() + start_[i];
    size_t length &#x3D; start_[i + 1] - start_[i];
    tmp_keys_[i] &#x3D; Slice(base, length);
  &#125;

  &#x2F;&#x2F; Generate filter for current set of keys and append to result_.
  filter_offsets_.push_back(result_.size());
  policy_-&gt;CreateFilter(&amp;tmp_keys_[0], static_cast&lt;int&gt;(num_keys), &amp;result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用顺序严格保证为(StartBlock,AddKeys*)*Finish。</p>
<p><code>class FilterBlockReader</code>读取filter数据，提供检查key是否匹配接口</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class FilterBlockReader &#123;
 public:
  &#x2F;&#x2F; REQUIRES: &quot;contents&quot; and *policy must stay live while *this is live.
  FilterBlockReader(const FilterPolicy* policy, const Slice&amp; contents);
  bool KeyMayMatch(uint64_t block_offset, const Slice&amp; key);

 private:
  const FilterPolicy* policy_;
  const char* data_;    &#x2F;&#x2F; Pointer to filter data (at block-start)
  const char* offset_;  &#x2F;&#x2F; Pointer to beginning of offset array (at block-end)
  size_t num_;          &#x2F;&#x2F; Number of entries in offset array
  size_t base_lg_;      &#x2F;&#x2F; Encoding parameter (see kFilterBaseLg in .cc file)
&#125;;

FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
                                     const Slice&amp; contents)
    : policy_(policy), data_(nullptr), offset_(nullptr), num_(0), base_lg_(0) &#123;
  size_t n &#x3D; contents.size();
  if (n &lt; 5) return;  &#x2F;&#x2F; 1 byte for base_lg_ and 4 for start of offset array
  base_lg_ &#x3D; contents[n - 1];
  uint32_t last_word &#x3D; DecodeFixed32(contents.data() + n - 5);
  if (last_word &gt; n - 5) return;
  data_ &#x3D; contents.data();
  offset_ &#x3D; data_ + last_word;
  num_ &#x3D; (n - 5 - last_word) &#x2F; 4;
&#125;

bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice&amp; key) &#123;
  uint64_t index &#x3D; block_offset &gt;&gt; base_lg_;
  if (index &lt; num_) &#123;
    uint32_t start &#x3D; DecodeFixed32(offset_ + index * 4);
    uint32_t limit &#x3D; DecodeFixed32(offset_ + index * 4 + 4);
    if (start &lt;&#x3D; limit &amp;&amp; limit &lt;&#x3D; static_cast&lt;size_t&gt;(offset_ - data_)) &#123;
      Slice filter &#x3D; Slice(data_ + start, limit - start);
      return policy_-&gt;KeyMayMatch(key, filter);
    &#125; else if (start &#x3D;&#x3D; limit) &#123;
      &#x2F;&#x2F; Empty filters do not match any keys
      return false;
    &#125;
  &#125;
  return true;  &#x2F;&#x2F; Errors are treated as potential matches
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个简单的例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;
    const leveldb::FilterPolicy* bloom_filter &#x3D; leveldb::NewBloomFilterPolicy(10);
    leveldb::FilterBlockBuilder filter_block_builder(bloom_filter);

    filter_block_builder.StartBlock(0);
    &#x2F;&#x2F;1000 1431 1109 0002 06
    filter_block_builder.AddKey(&quot;Hello&quot;);
    filter_block_builder.AddKey(&quot;World&quot;);
    filter_block_builder.StartBlock(3000);
    &#x2F;&#x2F;2002 0043 8821 4404 06
    filter_block_builder.AddKey(&quot;Go&quot;);
    filter_block_builder.AddKey(&quot;Programmer&quot;);
    filter_block_builder.StartBlock(20000);
    &#x2F;&#x2F;1a38 64d0 c001 8300 06
    filter_block_builder.AddKey(&quot;a&quot;);
    filter_block_builder.AddKey(&quot;b&quot;);
    filter_block_builder.AddKey(&quot;c&quot;);

    leveldb::Slice result &#x3D; filter_block_builder.Finish();

    leveldb::FilterBlockReader filter_block_reader(bloom_filter, result);
    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(0, &quot;Hello&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1
    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(0, &quot;World&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1
    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(0, &quot;Go&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;0
    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(3000, &quot;Go&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1
    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(20000, &quot;b&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1
    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(20000, &quot;d&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;0

    delete bloom_filter;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从KeyMayMatch的结果可以看到，block_offset的指定必须要准确。<br>result的结果如图所示：<br><img src="/../images/filter.png"></p>
<p>当从table中读取数据时，首先需要知道索引块的位置。Footer就是记录索引块的位置。<br>Footer位于sstabl最后48字节。其中40字节为索引块的位置，最后8字节为魔术字表明这个文件是sstable。索引块为DataIndexBlock和MetaIndexBlock。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Footer encapsulates the fixed information stored at the tail
&#x2F;&#x2F; end of every table file.
class Footer &#123;
 public:
  &#x2F;&#x2F; Encoded length of a Footer.  Note that the serialization of a
  &#x2F;&#x2F; Footer will always occupy exactly this many bytes.  It consists
  &#x2F;&#x2F; of two block handles and a magic number.
  enum &#123; kEncodedLength &#x3D; 2 * BlockHandle::kMaxEncodedLength + 8 &#125;;

  Footer() &#x3D; default;

  &#x2F;&#x2F; The block handle for the metaindex block of the table
  const BlockHandle&amp; metaindex_handle() const &#123; return metaindex_handle_; &#125;
  void set_metaindex_handle(const BlockHandle&amp; h) &#123; metaindex_handle_ &#x3D; h; &#125;

  &#x2F;&#x2F; The block handle for the index block of the table
  const BlockHandle&amp; index_handle() const &#123; return index_handle_; &#125;
  void set_index_handle(const BlockHandle&amp; h) &#123; index_handle_ &#x3D; h; &#125;

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

 private:
  BlockHandle metaindex_handle_;
  BlockHandle index_handle_;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>######SSTable<br>这样TableBuilder的设计就比较简单了，无非就是调用上述的BlockBuilder生成DataBlock,IndexBlock.调用FilterBlockBuilder生成FilterBlock.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TableBuilder::Rep &#123;
  &#x2F;&#x2F;......
  BlockBuilder data_block;
  BlockBuilder index_block;
  FilterBlockBuilder* filter_block;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>class Table</code> 读取sstable的索引信息，filter Data到内存，封装了查找数据的操作</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A Table is a sorted map from strings to strings.  Tables are
&#x2F;&#x2F; immutable and persistent.  A Table may be safely accessed from
&#x2F;&#x2F; multiple threads without external synchronization.
class LEVELDB_EXPORT Table &#123;
 public:
  &#x2F;&#x2F; Attempt to open the table that is stored in bytes [0..file_size)
  &#x2F;&#x2F; of &quot;file&quot;, and read the metadata entries necessary to allow
  &#x2F;&#x2F; retrieving data from the table.
  &#x2F;&#x2F;
  &#x2F;&#x2F; If successful, returns ok and sets &quot;*table&quot; to the newly opened
  &#x2F;&#x2F; table.  The client should delete &quot;*table&quot; when no longer needed.
  &#x2F;&#x2F; If there was an error while initializing the table, sets &quot;*table&quot;
  &#x2F;&#x2F; to nullptr and returns a non-ok status.  Does not take ownership of
  &#x2F;&#x2F; &quot;*source&quot;, but the client must ensure that &quot;source&quot; remains live
  &#x2F;&#x2F; for the duration of the returned table&#39;s lifetime.
  &#x2F;&#x2F;
  &#x2F;&#x2F; *file must remain live while this Table is in use.
  static Status Open(const Options&amp; options, RandomAccessFile* file,
                     uint64_t file_size, Table** table);

  Table(const Table&amp;) &#x3D; delete;
  Table&amp; operator&#x3D;(const Table&amp;) &#x3D; delete;

  ~Table();

  &#x2F;&#x2F; Returns a new iterator over the table contents.
  &#x2F;&#x2F; The result of NewIterator() is initially invalid (caller must
  &#x2F;&#x2F; call one of the Seek methods on the iterator before using it).
  Iterator* NewIterator(const ReadOptions&amp;) const;

  &#x2F;&#x2F; Given a key, return an approximate byte offset in the file where
  &#x2F;&#x2F; the data for that key begins (or would begin if the key were
  &#x2F;&#x2F; present in the file).  The returned value is in terms of file
  &#x2F;&#x2F; bytes, and so includes effects like compression of the underlying data.
  &#x2F;&#x2F; E.g., the approximate offset of the last key in the table will
  &#x2F;&#x2F; be close to the file length.
  uint64_t ApproximateOffsetOf(const Slice&amp; key) const;

 private:
  friend class TableCache;
  struct Rep;

  static Iterator* BlockReader(void*, const ReadOptions&amp;, const Slice&amp;);

  explicit Table(Rep* rep) : rep_(rep) &#123;&#125;

  &#x2F;&#x2F; Calls (*handle_result)(arg, ...) with the entry found after a call
  &#x2F;&#x2F; to Seek(key).  May not make such a call if filter policy says
  &#x2F;&#x2F; that key is not present.
  Status InternalGet(const ReadOptions&amp;, const Slice&amp; key, void* arg,
                     void (*handle_result)(void* arg, const Slice&amp; k,
                                           const Slice&amp; v));

  void ReadMeta(const Footer&amp; footer);
  void ReadFilter(const Slice&amp; filter_handle_value);
  Rep* const rep_;
&#125;;

struct Table::Rep &#123;
  ~Rep() &#123;
    delete filter;
    delete[] filter_data;
    delete index_block;
  &#125;
  Options options;
  Status status;
  RandomAccessFile* file;
  uint64_t cache_id; 
  FilterBlockReader* filter;
  const char* filter_data;

  BlockHandle metaindex_handle;  &#x2F;&#x2F; Handle to metaindex_block: saved from footer
  Block* index_block;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Open 函数首先读取file中的footer,解析出IndexBlockHandle 和MetaIndexBlockHandle。<br>然后读取IndexBlock块，存储指针到index_block中。Rep::cache_id 为该Table中的DataBlock被Cache时，key前8个字节。DataBlock的CacheKey由<code>Table::Req::cache_id</code> + DataBlock的大小。<br>最后调用ReadMeta读取出filter Block中的数据，存储指针到Rep::filter中。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char cache_key_buffer[16];
EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);
EncodeFixed64(cache_key_buffer + 8, handle.offset());
Slice key(cache_key_buffer, sizeof(cache_key_buffer));
cache_handle &#x3D; block_cache-&gt;Lookup(key);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status Table::Open(const Options&amp; options, RandomAccessFile* file,
                   uint64_t size, Table** table) &#123;
  *table &#x3D; nullptr;
  if (size &lt; Footer::kEncodedLength) &#123;
    return Status::Corruption(&quot;file is too short to be an sstable&quot;);
  &#125;

  char footer_space[Footer::kEncodedLength];
  Slice footer_input;
  Status s &#x3D; file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
                        &amp;footer_input, footer_space);
  if (!s.ok()) return s;

  Footer footer;
  s &#x3D; footer.DecodeFrom(&amp;footer_input);
  if (!s.ok()) return s;

  &#x2F;&#x2F; Read the index block
  BlockContents index_block_contents;
  ReadOptions opt;
  if (options.paranoid_checks) &#123;
    opt.verify_checksums &#x3D; true;
  &#125;
  s &#x3D; ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);

  if (s.ok()) &#123;
    &#x2F;&#x2F; We&#39;ve successfully read the footer and the index block: we&#39;re
    &#x2F;&#x2F; ready to serve requests.
    Block* index_block &#x3D; new Block(index_block_contents);
    Rep* rep &#x3D; new Table::Rep;
    rep-&gt;options &#x3D; options;
    rep-&gt;file &#x3D; file;
    rep-&gt;metaindex_handle &#x3D; footer.metaindex_handle();
    rep-&gt;index_block &#x3D; index_block;
    rep-&gt;cache_id &#x3D; (options.block_cache ? options.block_cache-&gt;NewId() : 0);
    rep-&gt;filter_data &#x3D; nullptr;
    rep-&gt;filter &#x3D; nullptr;
    *table &#x3D; new Table(rep);
    (*table)-&gt;ReadMeta(footer);
  &#125;
  return s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sstable的读取由二级迭代器封装了seek操作。第一级迭代器读取DataIndexBlock中的数据，定位到相应的 key-&gt;BlockHandle Entry处。第二级迭代器读取相应的DataBlock中的数据，定位到具体的key-&gt;value Entry。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Iterator* Table::NewIterator(const ReadOptions&amp; options) const &#123;
  return NewTwoLevelIterator(
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),
      &amp;Table::BlockReader, const_cast&lt;Table*&gt;(this), options);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TwoLevelIterator的Seek操作,首先调用一级迭代器(index_iter_)查找target，定位到某个Entry。然后初始化二级迭代器（data_iter_),最后调用二级迭代器查找target.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void TwoLevelIterator::Seek(const Slice&amp; target) &#123;
  index_iter_.Seek(target);
  InitDataBlock();
  if (data_iter_.iter() !&#x3D; nullptr) data_iter_.Seek(target);
  SkipEmptyDataBlocksForward();
&#125;

void TwoLevelIterator::SetDataIterator(Iterator* data_iter) &#123;
  if (data_iter_.iter() !&#x3D; nullptr) SaveError(data_iter_.status());
  data_iter_.Set(data_iter);
&#125;

void TwoLevelIterator::InitDataBlock() &#123;
  if (!index_iter_.Valid()) &#123;
    SetDataIterator(nullptr);
  &#125; else &#123;
    Slice handle &#x3D; index_iter_.value();
    if (data_iter_.iter() !&#x3D; nullptr &amp;&amp;
        handle.compare(data_block_handle_) &#x3D;&#x3D; 0) &#123;
      &#x2F;&#x2F; data_iter_ is already constructed with this iterator, so
      &#x2F;&#x2F; no need to change anything
    &#125; else &#123;
      Iterator* iter &#x3D; (*block_function_)(arg_, options_, handle);
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中初始化二级迭代器调用的是传入的Table::BlockReader函数。该函数读取Block数据，缓存到Block Cache中，最后返回该Block的迭代器。其中的缓存操作，根据ReadOption 中的fill_cache 和读出的BlockContents中的cacheable决定。如果实际的读取操作为从mmap映射中读取，则不会被cache。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Convert an index iterator value (i.e., an encoded BlockHandle)
&#x2F;&#x2F; into an iterator over the contents of the corresponding block.
Iterator* Table::BlockReader(void* arg, const ReadOptions&amp; options,
                             const Slice&amp; index_value) &#123;
  Table* table &#x3D; reinterpret_cast&lt;Table*&gt;(arg);
  Cache* block_cache &#x3D; table-&gt;rep_-&gt;options.block_cache;
  Block* block &#x3D; nullptr;
  Cache::Handle* cache_handle &#x3D; nullptr;

  BlockHandle handle;
  Slice input &#x3D; index_value;
  Status s &#x3D; handle.DecodeFrom(&amp;input);
  &#x2F;&#x2F; We intentionally allow extra stuff in index_value so that we
  &#x2F;&#x2F; can add more features in the future.

  if (s.ok()) &#123;
    BlockContents contents;
    if (block_cache !&#x3D; nullptr) &#123;
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);
      EncodeFixed64(cache_key_buffer + 8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle &#x3D; block_cache-&gt;Lookup(key);
      if (cache_handle !&#x3D; nullptr) &#123;
        block &#x3D; reinterpret_cast&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));
      &#125; else &#123;
        s &#x3D; ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);
        if (s.ok()) &#123;
          block &#x3D; new Block(contents);
          if (contents.cachable &amp;&amp; options.fill_cache) &#123;
            cache_handle &#x3D; block_cache-&gt;Insert(key, block, block-&gt;size(),
                                               &amp;DeleteCachedBlock);
          &#125;
        &#125;
      &#125;
    &#125; else &#123;
      s &#x3D; ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);
      if (s.ok()) &#123;
        block &#x3D; new Block(contents);
      &#125;
    &#125;
  &#125;

  Iterator* iter;
  if (block !&#x3D; nullptr) &#123;
    iter &#x3D; block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);
    if (cache_handle &#x3D;&#x3D; nullptr) &#123;
      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, nullptr);
    &#125; else &#123;
      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);
    &#125;
  &#125; else &#123;
    iter &#x3D; NewErrorIterator(s);
  &#125;
  return iter;
&#125;


&#x2F;&#x2F; Options that control read operations
struct LEVELDB_EXPORT ReadOptions &#123;
  ReadOptions() &#x3D; default;
&#x2F;&#x2F;......

  &#x2F;&#x2F; Should the data read for this iteration be cached in memory?
  &#x2F;&#x2F; Callers may wish to set this field to false for bulk scans.
  bool fill_cache &#x3D; true;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>











                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Taria</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tariaunique.github.io/2022/11/24/leveldb_sstable/">https://tariaunique.github.io/2022/11/24/leveldb_sstable/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Taria</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/11/24/leveldb_version&compaction/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-11-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Taria
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/11/24/leveldb_memtable/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-11-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Taria
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">Taria</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">13.8k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tariaunique" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:sunya3596@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
