<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="TariaUnique">
    <meta name="description" content="#####version&amp;amp;manifest
######VersionEditclass VersionEdit记录了磁盘每层文件的变更。每次compaction涉及到每层sstable文件的新增和删除，记录到VersionEdit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TariaUnique</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/matery.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/my.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/css/post.css">




    



    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TariaUnique</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TariaUnique</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-11-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-07-16
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    6.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    33 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>#####version&amp;manifest</p>
<p>######VersionEdit<br><code>class VersionEdit</code>记录了磁盘每层文件的变更。每次compaction涉及到每层sstable文件的新增和删除，记录到VersionEdit中。同时序列化到manifest文件。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct FileMetaData &#123;
  FileMetaData() : refs(0), allowed_seeks(1 &lt;&lt; 30), file_size(0) &#123;&#125;

  int refs;
  int allowed_seeks;  &#x2F;&#x2F; Seeks allowed until compaction
  uint64_t number;
  uint64_t file_size;    &#x2F;&#x2F; File size in bytes
  InternalKey smallest;  &#x2F;&#x2F; Smallest internal key served by table
  InternalKey largest;   &#x2F;&#x2F; Largest internal key served by table
&#125;;

class VersionEdit &#123;
 public:
  VersionEdit() &#123; Clear(); &#125;
  ~VersionEdit() &#x3D; default;

  void Clear();

  void SetComparatorName(const Slice&amp; name) &#123;
    has_comparator_ &#x3D; true;
    comparator_ &#x3D; name.ToString();
  &#125;
  void SetLogNumber(uint64_t num) &#123; 
    has_log_number_ &#x3D; true;
    log_number_ &#x3D; num;
  &#125;
  void SetPrevLogNumber(uint64_t num) &#123;
    has_prev_log_number_ &#x3D; true;
    prev_log_number_ &#x3D; num;
  &#125;
  void SetNextFile(uint64_t num) &#123;
    has_next_file_number_ &#x3D; true;
    next_file_number_ &#x3D; num;
  &#125;
  void SetLastSequence(SequenceNumber seq) &#123;
    has_last_sequence_ &#x3D; true;
    last_sequence_ &#x3D; seq;
  &#125;
  void SetCompactPointer(int level, const InternalKey&amp; key) &#123;
    compact_pointers_.push_back(std::make_pair(level, key));
  &#125;

  &#x2F;&#x2F; Add the specified file at the specified number.
  &#x2F;&#x2F; REQUIRES: This version has not been saved (see VersionSet::SaveTo)
  &#x2F;&#x2F; REQUIRES: &quot;smallest&quot; and &quot;largest&quot; are smallest and largest keys in file
  void AddFile(int level, uint64_t file, uint64_t file_size,
               const InternalKey&amp; smallest, const InternalKey&amp; largest) &#123;
    FileMetaData f;
    f.number &#x3D; file;
    f.file_size &#x3D; file_size;
    f.smallest &#x3D; smallest;
    f.largest &#x3D; largest;
    new_files_.push_back(std::make_pair(level, f));
  &#125;

  &#x2F;&#x2F; Delete the specified &quot;file&quot; from the specified &quot;level&quot;.
  void RemoveFile(int level, uint64_t file) &#123;
    deleted_files_.insert(std::make_pair(level, file));
  &#125;

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(const Slice&amp; src);

  std::string DebugString() const;

 private:
  friend class VersionSet;

  typedef std::set&lt;std::pair&lt;int, uint64_t&gt;&gt; DeletedFileSet;

  std::string comparator_;
  uint64_t log_number_;
  uint64_t prev_log_number_;
  uint64_t next_file_number_;
  SequenceNumber last_sequence_;
  bool has_comparator_;
  bool has_log_number_;
  bool has_prev_log_number_;
  bool has_next_file_number_;
  bool has_last_sequence_;

  std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;
  DeletedFileSet deleted_files_;
  std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主要的文件变更记录到new_files_和deleted_files_中。</p>
<p>######Version<br><code>class Version</code>为磁盘文件的某一个版本。主要记录了每层的sstable的FileMetaData。版本的变更连接为双层链表。同时该类封装了从该版本查找数据的接口。DB的Get操作，查找到sstable时，入口是Version::Get()。<br>除此之外，每次compaction时，所需的compaction信息也是从当前的version获得。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LookupKey lkey(key, snapshot);
if (mem-&gt;Get(lkey, value, &amp;s)) &#123;
  &#x2F;&#x2F; Done
&#125; else if (imm !&#x3D; nullptr &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;
  &#x2F;&#x2F; Done
&#125; else &#123;
  s &#x3D; current-&gt;Get(options, lkey, value, &amp;stats);
  have_stat_update &#x3D; true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Version的主要数据成员如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Version &#123;
private:
  VersionSet* vset_;  &#x2F;&#x2F; VersionSet to which this Version belongs
  Version* next_;     &#x2F;&#x2F; Next version in linked list
  Version* prev_;     &#x2F;&#x2F; Previous version in linked list
  int refs_;          &#x2F;&#x2F; Number of live refs to this version

  &#x2F;&#x2F; List of files per level
  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];

  &#x2F;&#x2F; Next file to compact based on seek stats.
  FileMetaData* file_to_compact_;
  int file_to_compact_level_;

  &#x2F;&#x2F; Level that should be compacted next and its compaction score.
  &#x2F;&#x2F; Score &lt; 1 means compaction is not strictly needed.  These fields
  &#x2F;&#x2F; are initialized by Finalize().
  double compaction_score_;
  int compaction_level_;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当immutable memtable 需要压缩时，首先将immemtable序列化到新的sstable中。使用memtable 的迭代器按序读取，并使用TableBuilder 的Add()。<br>在序列化的过程中，不持有锁。所以别的线程可以读取immemtable。序列化完成后，磁盘存入新的sstable,meta记录sstable的FileMetaData。同时,<br>table_cache_调用Table::Open()打开这个新生成的sstale,存入Table_Cache缓存中</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
                                Version* base) &#123;
  mutex_.AssertHeld();
  const uint64_t start_micros &#x3D; env_-&gt;NowMicros();
  FileMetaData meta;
  meta.number &#x3D; versions_-&gt;NewFileNumber();
  pending_outputs_.insert(meta.number);
  Iterator* iter &#x3D; mem-&gt;NewIterator();
  Log(options_.info_log, &quot;Level-0 table #%llu: started&quot;,
      (unsigned long long)meta.number);

  Status s;
  &#123;
    mutex_.Unlock();
    s &#x3D; BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);
    mutex_.Lock();
  &#125;
   &#x2F;&#x2F;.....
&#125;
Status BuildTable(const std::string&amp; dbname, Env* env, const Options&amp; options,
                  TableCache* table_cache, Iterator* iter, FileMetaData* meta) &#123;
    &#x2F;&#x2F;......使用TableBuilder序列化key,value 到新的sstable中
    &#x2F;&#x2F; Finish and check for file errors
    if (s.ok()) &#123;
      s &#x3D; file-&gt;Sync();
    &#125;
    if (s.ok()) &#123;
      s &#x3D; file-&gt;Close();
    &#125;
    delete file;
    file &#x3D; nullptr;

    if (s.ok()) &#123;
      &#x2F;&#x2F; Verify that the table is usable
      &#x2F;&#x2F;这一步会打开新生成的sstable，加入缓存
      Iterator* it &#x3D; table_cache-&gt;NewIterator(ReadOptions(), meta-&gt;number,
                                              meta-&gt;file_size);
      s &#x3D; it-&gt;status();
      delete it;
    &#125;
    &#x2F;&#x2F;......
&#125;
现在磁盘多了一个sstable文件，需要决定将它放入level0还是更高的level中。调用version的PickLevelForMemTableOutput接口。
具体规则为，如果新的sstable的key范围跟level1所有文件不重叠，并且，跟level2重叠的文件大小不超过10*max_file_size。即重叠不超过10个文件，则可以直接放到level1中。
同规则适应到level2。最多存放到level2中.这个push规则，即减少了level0 sstables的数量。同时，也不至于push的level太高了影响读取。
level0 sstable的数量如果过多，会影响到写入的延迟。
当push的level决定之后，就将修改写入edit中。这里只有新增文件，记录到edit的new_files_中。
&#96;&#96;&#96;c++
Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
                                Version* base) &#123;
  &#x2F;&#x2F;......
  &#x2F;&#x2F; Note that if file_size is zero, the file has been deleted and
  &#x2F;&#x2F; should not be added to the manifest.
  int level &#x3D; 0;
  if (s.ok() &amp;&amp; meta.file_size &gt; 0) &#123;
    const Slice min_user_key &#x3D; meta.smallest.user_key();
    const Slice max_user_key &#x3D; meta.largest.user_key();
    if (base !&#x3D; nullptr) &#123;
      level &#x3D; base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);
    &#125;
    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,
                  meta.largest);
  &#125;
  &#x2F;&#x2F;......
&#125;


int Version::PickLevelForMemTableOutput(const Slice&amp; smallest_user_key,
                                        const Slice&amp; largest_user_key) &#123;
  int level &#x3D; 0;
  if (!OverlapInLevel(0, &amp;smallest_user_key, &amp;largest_user_key)) &#123;
    &#x2F;&#x2F; Push to next level if there is no overlap in next level,
    &#x2F;&#x2F; and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));
    std::vector&lt;FileMetaData*&gt; overlaps;
    while (level &lt; config::kMaxMemCompactLevel) &#123;
      if (OverlapInLevel(level + 1, &amp;smallest_user_key, &amp;largest_user_key)) &#123;
        break;
      &#125;
      if (level + 2 &lt; config::kNumLevels) &#123;
        &#x2F;&#x2F; Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &amp;start, &amp;limit, &amp;overlaps);
        const int64_t sum &#x3D; TotalFileSize(overlaps);
        if (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;
          break;
        &#125;
      &#125;
      level++;
    &#125;
  &#125;
  return level;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后immemtable 的wal文件可以被删除。首先将新版本的prev_log_number置为0，记录到edit中，表示wal log的变更。<br>然后调用VersionSet::LogAndApply(),其中调用Builder::Apply(), Builder::SaveTo()生成新的version，同时将edit写入manifest文件中。如果manifest文件之前为空，需要<br>将current_ version 转化为edit,写入初始的edit，然后将新增的edit写入manifest。最后应用新的version.即将version连入链表，并将current_指向新的version.<br>最后删除prev wal log 文件。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DBImpl::CompactMemTable() &#123;
    &#x2F;&#x2F;......
  if (s.ok()) &#123;
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  &#x2F;&#x2F; Earlier logs no longer needed
    s &#x3D; versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);
  &#125;

  if (s.ok()) &#123;
    &#x2F;&#x2F; Commit to the new state
    imm_-&gt;Unref();
    imm_ &#x3D; nullptr;
    has_imm_.store(false, std::memory_order_release);
    RemoveObsoleteFiles();
  &#125;
  &#x2F;&#x2F;.......
&#125;
Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;
  if (edit-&gt;has_log_number_) &#123;
    assert(edit-&gt;log_number_ &gt;&#x3D; log_number_);
    assert(edit-&gt;log_number_ &lt; next_file_number_);
  &#125; else &#123;
    edit-&gt;SetLogNumber(log_number_);
  &#125;

  if (!edit-&gt;has_prev_log_number_) &#123;
    edit-&gt;SetPrevLogNumber(prev_log_number_);
  &#125;

  edit-&gt;SetNextFile(next_file_number_);
  edit-&gt;SetLastSequence(last_sequence_);

  Version* v &#x3D; new Version(this);
  &#123;
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  &#125;
  Finalize(v); &#x2F;&#x2F;这里主要时计算新的version的compaction 信息，暂时略过

  &#x2F;&#x2F; Initialize new descriptor log file if necessary by creating
  &#x2F;&#x2F; a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s;
  if (descriptor_log_ &#x3D;&#x3D; nullptr) &#123;
    &#x2F;&#x2F; No reason to unlock *mu here since we only hit this path in the
    &#x2F;&#x2F; first call to LogAndApply (when opening the database).
    assert(descriptor_file_ &#x3D;&#x3D; nullptr);
    new_manifest_file &#x3D; DescriptorFileName(dbname_, manifest_file_number_);
    edit-&gt;SetNextFile(next_file_number_);
    s &#x3D; env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);
    if (s.ok()) &#123;
      descriptor_log_ &#x3D; new log::Writer(descriptor_file_);
      s &#x3D; WriteSnapshot(descriptor_log_); &#x2F;&#x2F;将当前version转为edit存入新的manifest文件。
    &#125;
  &#125;

  &#x2F;&#x2F; Unlock during expensive MANIFEST log write
  &#123;
    mu-&gt;Unlock();

    &#x2F;&#x2F; Write new record to MANIFEST log
    if (s.ok()) &#123;
      std::string record;
      edit-&gt;EncodeTo(&amp;record);
      s &#x3D; descriptor_log_-&gt;AddRecord(record);
      if (s.ok()) &#123;
        s &#x3D; descriptor_file_-&gt;Sync();
      &#125;
      if (!s.ok()) &#123;
        Log(options_-&gt;info_log, &quot;MANIFEST write: %s\n&quot;, s.ToString().c_str());
      &#125;
    &#125;

    &#x2F;&#x2F; If we just created a new descriptor file, install it by writing a
    &#x2F;&#x2F; new CURRENT file that points to it.
    if (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;
      s &#x3D; SetCurrentFile(env_, dbname_, manifest_file_number_);
    &#125;

    mu-&gt;Lock();
  &#125;

  &#x2F;&#x2F; Install the new version
  if (s.ok()) &#123;
    AppendVersion(v);
    log_number_ &#x3D; edit-&gt;log_number_;
    prev_log_number_ &#x3D; edit-&gt;prev_log_number_;
  &#125; else &#123;
    delete v;
    if (!new_manifest_file.empty()) &#123;
      delete descriptor_log_;
      delete descriptor_file_;
      descriptor_log_ &#x3D; nullptr;
      descriptor_file_ &#x3D; nullptr;
      env_-&gt;RemoveFile(new_manifest_file);
    &#125;
  &#125;
  return s;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>class VersionSet::Builder 根据前一个Version版本，以及新版本的VersionEdit变更记录，生成新的Version<br>数据成员如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A helper class so we can efficiently apply a whole sequence
&#x2F;&#x2F; of edits to a particular state without creating intermediate
&#x2F;&#x2F; Versions that contain full copies of the intermediate state.
class VersionSet::Builder &#123;
 private:
  &#x2F;&#x2F; Helper to sort by v-&gt;files_[file_number].smallest
  struct BySmallestKey &#123;
    const InternalKeyComparator* internal_comparator;

    bool operator()(FileMetaData* f1, FileMetaData* f2) const &#123;
      int r &#x3D; internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);
      if (r !&#x3D; 0) &#123;
        return (r &lt; 0);
      &#125; else &#123;
        &#x2F;&#x2F; Break ties by file number
        return (f1-&gt;number &lt; f2-&gt;number);
      &#125;
    &#125;
  &#125;;

  typedef std::set&lt;FileMetaData*, BySmallestKey&gt; FileSet;
  struct LevelState &#123;
    std::set&lt;uint64_t&gt; deleted_files;
    FileSet* added_files;
  &#125;;

  VersionSet* vset_;
  Version* base_;
  LevelState levels_[config::kNumLevels];
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主要操作为Apply和SaveTo</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Apply(VersionEdit* edit) &#123;
  &#x2F;&#x2F; Update compaction pointers
  for (size_t i &#x3D; 0; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;
    const int level &#x3D; edit-&gt;compact_pointers_[i].first;
    vset_-&gt;compact_pointer_[level] &#x3D;
        edit-&gt;compact_pointers_[i].second.Encode().ToString();
  &#125;

  &#x2F;&#x2F; Delete files
  for (const auto&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;
    const int level &#x3D; deleted_file_set_kvp.first;
    const uint64_t number &#x3D; deleted_file_set_kvp.second;
    levels_[level].deleted_files.insert(number);
  &#125;

  &#x2F;&#x2F; Add new files
  for (size_t i &#x3D; 0; i &lt; edit-&gt;new_files_.size(); i++) &#123;
    const int level &#x3D; edit-&gt;new_files_[i].first;
    FileMetaData* f &#x3D; new FileMetaData(edit-&gt;new_files_[i].second);
    f-&gt;refs &#x3D; 1;
    &#x2F;&#x2F;....

    levels_[level].deleted_files.erase(f-&gt;number);
    levels_[level].added_files-&gt;insert(f);
  &#125;
&#125;

  &#x2F;&#x2F; Save the current state in *v.
void SaveTo(Version* v) &#123;
  BySmallestKey cmp;
  cmp.internal_comparator &#x3D; &amp;vset_-&gt;icmp_;
  for (int level &#x3D; 0; level &lt; config::kNumLevels; level++) &#123;
    &#x2F;&#x2F; Merge the set of added files with the set of pre-existing files.
    &#x2F;&#x2F; Drop any deleted files.  Store the result in *v.
    const std::vector&lt;FileMetaData*&gt;&amp; base_files &#x3D; base_-&gt;files_[level];
    std::vector&lt;FileMetaData*&gt;::const_iterator base_iter &#x3D; base_files.begin();
    std::vector&lt;FileMetaData*&gt;::const_iterator base_end &#x3D; base_files.end();
    const FileSet* added_files &#x3D; levels_[level].added_files;
    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());
    for (const auto&amp; added_file : *added_files) &#123;
      &#x2F;&#x2F; Add all smaller files listed in base_
      for (std::vector&lt;FileMetaData*&gt;::const_iterator bpos &#x3D;
               std::upper_bound(base_iter, base_end, added_file, cmp);
           base_iter !&#x3D; bpos; ++base_iter) &#123;
        MaybeAddFile(v, level, *base_iter); &#x2F;&#x2F;MaybeAddFile：如果该文件被删除，则不添加。
      &#125;

      MaybeAddFile(v, level, added_file);
    &#125;

    &#x2F;&#x2F; Add remaining base files
    for (; base_iter !&#x3D; base_end; ++base_iter) &#123;
      MaybeAddFile(v, level, *base_iter);
    &#125;
    &#x2F;&#x2F;....
  &#125;
&#125;
void MaybeAddFile(Version* v, int level, FileMetaData* f) &#123;
  if (levels_[level].deleted_files.count(f-&gt;number) &gt; 0) &#123;
    &#x2F;&#x2F; File is deleted: do nothing
  &#125; else &#123;
    std::vector&lt;FileMetaData*&gt;* files &#x3D; &amp;v-&gt;files_[level];
    if (level &gt; 0 &amp;&amp; !files-&gt;empty()) &#123;
      &#x2F;&#x2F; Must not overlap
      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - 1]-&gt;largest,
                                  f-&gt;smallest) &lt; 0);
    &#125;
    f-&gt;refs++;
    files-&gt;push_back(f);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>######sstable compaction<br>sstable compaction 的触发条件主要由两个，其一是根据各层文件大小和数量决定是否compaction,以及compact哪一层sstable。这个判断条件在每生成新的version时计算值。<br>对于level0,只判断sstables数量。<br>level1-7 compaction 总大小为10M,10*10M….<br><code>Version::compaction_level_</code>和<code>Version::compaction_score</code>在新version生成时计算(也即磁盘文件的一次compact后)，在该version生效期间保持不变，直到下一个version生成。<br>很有可能一个verison刚生成，他的compaction_score 就已经大于1了，比如，immutable memtable-&gt;level0 sstable，使得level0的sstables文件数量超过4个，新生成的version，score&gt;1,level为0<br>或者前一个compaction导致下层的文件大小超过压缩限制，也会触发下一层compaction。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void VersionSet::Finalize(Version* v) &#123;
  &#x2F;&#x2F; Precomputed best level for next compaction
  int best_level &#x3D; -1;
  double best_score &#x3D; -1;

  for (int level &#x3D; 0; level &lt; config::kNumLevels - 1; level++) &#123;
    double score;
    if (level &#x3D;&#x3D; 0) &#123;
      &#x2F;&#x2F; We treat level-0 specially by bounding the number of files
      &#x2F;&#x2F; instead of number of bytes for two reasons:
      &#x2F;&#x2F;
      &#x2F;&#x2F; (1) With larger write-buffer sizes, it is nice not to do too
      &#x2F;&#x2F; many level-0 compactions.
      &#x2F;&#x2F;
      &#x2F;&#x2F; (2) The files in level-0 are merged on every read and
      &#x2F;&#x2F; therefore we wish to avoid too many files when the individual
      &#x2F;&#x2F; file size is small (perhaps because of a small write-buffer
      &#x2F;&#x2F; setting, or very high compression ratios, or lots of
      &#x2F;&#x2F; overwrites&#x2F;deletions).
      score &#x3D; v-&gt;files_[level].size() &#x2F;
              static_cast&lt;double&gt;(config::kL0_CompactionTrigger);
    &#125; else &#123;
      &#x2F;&#x2F; Compute the ratio of current size to size limit.
      const uint64_t level_bytes &#x3D; TotalFileSize(v-&gt;files_[level]);
      score &#x3D;
          static_cast&lt;double&gt;(level_bytes) &#x2F; MaxBytesForLevel(options_, level);
    &#125;

    if (score &gt; best_score) &#123;
      best_level &#x3D; level;
      best_score &#x3D; score;
    &#125;
  &#125;

  v-&gt;compaction_level_ &#x3D; best_level;
  v-&gt;compaction_score_ &#x3D; best_score;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个触发条件为Get操作，查询到sstable，某个文件被查询，却没有找到。每个sstable在生成时会有allowed_seek属性。<br>默认为文件大小除以12kb。该属性表示被seek，却没有找到的次数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Builder::Apply()&#123;
    &#x2F;&#x2F;......

    &#x2F;&#x2F; Add new files
    for (size_t i &#x3D; 0; i &lt; edit-&gt;new_files_.size(); i++) &#123;
      const int level &#x3D; edit-&gt;new_files_[i].first;
      FileMetaData* f &#x3D; new FileMetaData(edit-&gt;new_files_[i].second);
      f-&gt;refs &#x3D; 1;

      &#x2F;&#x2F; We arrange to automatically compact this file after
      &#x2F;&#x2F; a certain number of seeks.  Let&#39;s assume:
      &#x2F;&#x2F;   (1) One seek costs 10ms
      &#x2F;&#x2F;   (2) Writing or reading 1MB costs 10ms (100MB&#x2F;s)
      &#x2F;&#x2F;   (3) A compaction of 1MB does 25MB of IO:
      &#x2F;&#x2F;         1MB read from this level
      &#x2F;&#x2F;         10-12MB read from next level (boundaries may be misaligned)
      &#x2F;&#x2F;         10-12MB written to next level
      &#x2F;&#x2F; This implies that 25 seeks cost the same as the compaction
      &#x2F;&#x2F; of 1MB of data.  I.e., one seek costs approximately the
      &#x2F;&#x2F; same as the compaction of 40KB of data.  We are a little
      &#x2F;&#x2F; conservative and allow approximately one seek for every 16KB
      &#x2F;&#x2F; of data before triggering a compaction.
      f-&gt;allowed_seeks &#x3D; static_cast&lt;int&gt;((f-&gt;file_size &#x2F; 16384U));
      if (f-&gt;allowed_seeks &lt; 100) f-&gt;allowed_seeks &#x3D; 100;

      levels_[level].deleted_files.erase(f-&gt;number);
      levels_[level].added_files-&gt;insert(f);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>VersionSet::PickCompaction()</code>设置好需要compact的两层sstables,以及其他相关的compact信息到Compaction中，<br>实际压缩时，根据Compaction中的信息进行压缩。<br>如果的文件大小或者数量超过限制，则levelL层压缩文件的选择从上次compact_point开始，如果为0层，需要找到所有与之重叠的范围。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Compaction* VersionSet::PickCompaction() &#123;
  Compaction* c;
  int level;

  &#x2F;&#x2F; We prefer compactions triggered by too much data in a level over
  &#x2F;&#x2F; the compactions triggered by seeks.
  const bool size_compaction &#x3D; (current_-&gt;compaction_score_ &gt;&#x3D; 1);
  const bool seek_compaction &#x3D; (current_-&gt;file_to_compact_ !&#x3D; nullptr);
  if (size_compaction) &#123;
    level &#x3D; current_-&gt;compaction_level_;
    assert(level &gt;&#x3D; 0);
    assert(level + 1 &lt; config::kNumLevels);
    c &#x3D; new Compaction(options_, level);

    &#x2F;&#x2F; Pick the first file that comes after compact_pointer_[level]
    for (size_t i &#x3D; 0; i &lt; current_-&gt;files_[level].size(); i++) &#123;
      FileMetaData* f &#x3D; current_-&gt;files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; 0) &#123;
        c-&gt;inputs_[0].push_back(f);
        break;
      &#125;
    &#125;
    if (c-&gt;inputs_[0].empty()) &#123;
      &#x2F;&#x2F; Wrap-around to the beginning of the key space
      c-&gt;inputs_[0].push_back(current_-&gt;files_[level][0]);
    &#125;
  &#125; else if (seek_compaction) &#123;
    level &#x3D; current_-&gt;file_to_compact_level_;
    c &#x3D; new Compaction(options_, level);
    c-&gt;inputs_[0].push_back(current_-&gt;file_to_compact_);
  &#125; else &#123;
    return nullptr;
  &#125;

  c-&gt;input_version_ &#x3D; current_;
  c-&gt;input_version_-&gt;Ref();

  &#x2F;&#x2F; Files in level 0 may overlap each other, so pick up all overlapping ones
  if (level &#x3D;&#x3D; 0) &#123;
    InternalKey smallest, largest;
    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);
    &#x2F;&#x2F; Note that the next call will discard the file we placed in
    &#x2F;&#x2F; c-&gt;inputs_[0] earlier and replace it with an overlapping set
    &#x2F;&#x2F; which will include the picked file.
    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);
    assert(!c-&gt;inputs_[0].empty());
  &#125;

  SetupOtherInputs(c);

  return c;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中Version::GetOverlappingInputs()函数对level0层重叠范围文件的查询有特殊操作。<br>对其他层文件，只需要一个一个判断有没有重叠。对level0层，当找到一个重叠文件后，需要看是否扩大了范围。<br>注意这里判断overlap比较的是userkey而不是interkey。同时这里只对level0生效。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Version::GetOverlappingInputs(int level, const InternalKey* begin,
                                   const InternalKey* end,
                                   std::vector&lt;FileMetaData*&gt;* inputs) &#123;
  assert(level &gt;&#x3D; 0);
  assert(level &lt; config::kNumLevels);
  inputs-&gt;clear();
  Slice user_begin, user_end;
  if (begin !&#x3D; nullptr) &#123;
    user_begin &#x3D; begin-&gt;user_key();
  &#125;
  if (end !&#x3D; nullptr) &#123;
    user_end &#x3D; end-&gt;user_key();
  &#125;
  const Comparator* user_cmp &#x3D; vset_-&gt;icmp_.user_comparator();
  for (size_t i &#x3D; 0; i &lt; files_[level].size();) &#123;
    FileMetaData* f &#x3D; files_[level][i++];
    const Slice file_start &#x3D; f-&gt;smallest.user_key();
    const Slice file_limit &#x3D; f-&gt;largest.user_key();
    if (begin !&#x3D; nullptr &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; 0) &#123;
      &#x2F;&#x2F; &quot;f&quot; is completely before specified range; skip it
    &#125; else if (end !&#x3D; nullptr &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; 0) &#123;
      &#x2F;&#x2F; &quot;f&quot; is completely after specified range; skip it
    &#125; else &#123;
      inputs-&gt;push_back(f);
      if (level &#x3D;&#x3D; 0) &#123;
        &#x2F;&#x2F; Level-0 files may overlap each other.  So check if the newly
        &#x2F;&#x2F; added file has expanded the range.  If so, restart search.
        if (begin !&#x3D; nullptr &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; 0) &#123;
          user_begin &#x3D; file_start;
          inputs-&gt;clear();
          i &#x3D; 0;
        &#125; else if (end !&#x3D; nullptr &amp;&amp;
                   user_cmp-&gt;Compare(file_limit, user_end) &gt; 0) &#123;
          user_end &#x3D; file_limit;
          inputs-&gt;clear();
          i &#x3D; 0;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Version::SetupOtherInputs()</code>主要设置level+1层压缩文件。<br>首先对于之前获取的level层文件，需要扩展其boundary 文件，所谓boundary files就是其最小的key&gt;input[0]所有文件key范围最大的key,但是其user_key相等。<br>这在level&gt;0是完全有可能的。同时这样的边界文件可能不止一个。具体代码见<code>AddBoundaryInputs</code>。同时，对于level0层文件，是不会有边界拓展的，因为level0层文件的overlap判断就是以user_key为判断条件的。<br>根据扩展后的level 层文件范围，获取level+1层文件，同时检查level+1层的边界文件。<br>level+1层的文件范围可能大于level层，再去level层判断会不会有包含在level+1层范围之内的文件……<br>总之这段代码就是尽量多的扩展压缩范围，同时保证压缩的所有文件大小小于25*max_file_size。<br>最后记录下范围重叠的level+2层文件，更新compaction_point.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void VersionSet::SetupOtherInputs(Compaction* c) &#123;
  const int level &#x3D; c-&gt;level();
  InternalKey smallest, largest;

  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[0]);
  GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);

  current_-&gt;GetOverlappingInputs(level + 1, &amp;smallest, &amp;largest,
                                 &amp;c-&gt;inputs_[1]);
  AddBoundaryInputs(icmp_, current_-&gt;files_[level + 1], &amp;c-&gt;inputs_[1]);

  &#x2F;&#x2F; Get entire range covered by compaction
  InternalKey all_start, all_limit;
  GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);

  &#x2F;&#x2F; See if we can grow the number of inputs in &quot;level&quot; without
  &#x2F;&#x2F; changing the number of &quot;level+1&quot; files we pick up.
  if (!c-&gt;inputs_[1].empty()) &#123;
    std::vector&lt;FileMetaData*&gt; expanded0;
    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);
    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);
    const int64_t inputs0_size &#x3D; TotalFileSize(c-&gt;inputs_[0]);
    const int64_t inputs1_size &#x3D; TotalFileSize(c-&gt;inputs_[1]);
    const int64_t expanded0_size &#x3D; TotalFileSize(expanded0);
    if (expanded0.size() &gt; c-&gt;inputs_[0].size() &amp;&amp;
        inputs1_size + expanded0_size &lt;
            ExpandedCompactionByteSizeLimit(options_)) &#123;
      InternalKey new_start, new_limit;
      GetRange(expanded0, &amp;new_start, &amp;new_limit);
      std::vector&lt;FileMetaData*&gt; expanded1;
      current_-&gt;GetOverlappingInputs(level + 1, &amp;new_start, &amp;new_limit,
                                     &amp;expanded1);
      AddBoundaryInputs(icmp_, current_-&gt;files_[level + 1], &amp;expanded1);
      if (expanded1.size() &#x3D;&#x3D; c-&gt;inputs_[1].size()) &#123;
        Log(options_-&gt;info_log,
            &quot;Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n&quot;,
            level, int(c-&gt;inputs_[0].size()), int(c-&gt;inputs_[1].size()),
            long(inputs0_size), long(inputs1_size), int(expanded0.size()),
            int(expanded1.size()), long(expanded0_size), long(inputs1_size));
        smallest &#x3D; new_start;
        largest &#x3D; new_limit;
        c-&gt;inputs_[0] &#x3D; expanded0;
        c-&gt;inputs_[1] &#x3D; expanded1;
        GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);
      &#125;
    &#125;
  &#125;

  &#x2F;&#x2F; Compute the set of grandparent files that overlap this compaction
  &#x2F;&#x2F; (parent &#x3D;&#x3D; level+1; grandparent &#x3D;&#x3D; level+2)
  if (level + 2 &lt; config::kNumLevels) &#123;
    current_-&gt;GetOverlappingInputs(level + 2, &amp;all_start, &amp;all_limit,
                                   &amp;c-&gt;grandparents_);
  &#125;

  &#x2F;&#x2F; Update the place where we will do the next compaction for this level.
  &#x2F;&#x2F; We update this immediately instead of waiting for the VersionEdit
  &#x2F;&#x2F; to be applied so that if the compaction fails, we will try a different
  &#x2F;&#x2F; key range next time.
  compact_pointer_[level] &#x3D; largest.Encode().ToString();
  c-&gt;edit_.SetCompactPointer(level, largest);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后的压缩操作主要就是生成MergeIterator,从小到大遍历所有的key,根据snapshot，去掉相应的overwritten和删除的key。</p>
<p>首先看下MergeIterator。MergeIterator就是多个迭代器的封装。其Seek操作，为每个迭代器都Seek，<br>取其指向最小的迭代器，作为current_迭代器。其Next()操作，current_++，再取其所有迭代器指向的key最小的迭代器作为current_。<br>对于需要压缩的<code>std::vector&lt;FileMetaData*&gt; inputs_[2]</code>,如果inputs_[0]所压缩的文件为level 0 层文件，则Merge迭代器中children_数量为inputs[0].size()+1,<br>每个level0 层sstable一个Table::Iterator。level 1层文件一个二级迭代器，第一级遍历<code>vector&lt;FileMetaData*&gt;</code>数组，第二级遍历相应的文件。<br>如果inputs_[0]所压缩的level不为第0层，则MergeIterator中children_迭代器为两个，为每层的二级迭代器。其原因无非就是，level0层文件之前有重叠，不是整体有序的。<br>MergeIterator</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MergingIterator : public Iterator &#123;
 public:
  MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(nullptr),
        direction_(kForward) &#123;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
      children_[i].Set(children[i]);
    &#125;
  &#125;

  ~MergingIterator() override &#123; delete[] children_; &#125;

  bool Valid() const override &#123; return (current_ !&#x3D; nullptr); &#125;

  void SeekToFirst() override &#123;
    for (int i &#x3D; 0; i &lt; n_; i++) &#123;
      children_[i].SeekToFirst();
    &#125;
    FindSmallest();
    direction_ &#x3D; kForward;
  &#125;

  void SeekToLast() override &#123;
    for (int i &#x3D; 0; i &lt; n_; i++) &#123;
      children_[i].SeekToLast();
    &#125;
    FindLargest();
    direction_ &#x3D; kReverse;
  &#125;

  void Seek(const Slice&amp; target) override &#123;
    for (int i &#x3D; 0; i &lt; n_; i++) &#123;
      children_[i].Seek(target);
    &#125;
    FindSmallest();
    direction_ &#x3D; kForward;
  &#125;

  void Next() override &#123;
    assert(Valid());

    &#x2F;&#x2F; Ensure that all children are positioned after key().
    &#x2F;&#x2F; If we are moving in the forward direction, it is already
    &#x2F;&#x2F; true for all of the non-current_ children since current_ is
    &#x2F;&#x2F; the smallest child and key() &#x3D;&#x3D; current_-&gt;key().  Otherwise,
    &#x2F;&#x2F; we explicitly position the non-current_ children.
    if (direction_ !&#x3D; kForward) &#123;
      for (int i &#x3D; 0; i &lt; n_; i++) &#123;
        IteratorWrapper* child &#x3D; &amp;children_[i];
        if (child !&#x3D; current_) &#123;
          child-&gt;Seek(key());
          if (child-&gt;Valid() &amp;&amp;
              comparator_-&gt;Compare(key(), child-&gt;key()) &#x3D;&#x3D; 0) &#123;
            child-&gt;Next();
          &#125;
        &#125;
      &#125;
      direction_ &#x3D; kForward;
    &#125;

    current_-&gt;Next();
    FindSmallest();
  &#125;
&#x2F;&#x2F;......
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>MakeInputIterator</code>根据input_生成MergeIterator。fill_cache为false,即Iterator访问的Block不缓存。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Iterator* VersionSet::MakeInputIterator(Compaction* c) &#123;
  ReadOptions options;
  options.verify_checksums &#x3D; options_-&gt;paranoid_checks;
  options.fill_cache &#x3D; false;

  &#x2F;&#x2F; Level-0 files have to be merged together.  For other levels,
  &#x2F;&#x2F; we will make a concatenating iterator per level.
  &#x2F;&#x2F; TODO(opt): use concatenating iterator for level-0 if there is no overlap
  const int space &#x3D; (c-&gt;level() &#x3D;&#x3D; 0 ? c-&gt;inputs_[0].size() + 1 : 2);
  Iterator** list &#x3D; new Iterator*[space];
  int num &#x3D; 0;
  for (int which &#x3D; 0; which &lt; 2; which++) &#123;
    if (!c-&gt;inputs_[which].empty()) &#123;
      if (c-&gt;level() + which &#x3D;&#x3D; 0) &#123;
        const std::vector&lt;FileMetaData*&gt;&amp; files &#x3D; c-&gt;inputs_[which];
        for (size_t i &#x3D; 0; i &lt; files.size(); i++) &#123;
          list[num++] &#x3D; table_cache_-&gt;NewIterator(options, files[i]-&gt;number,
                                                  files[i]-&gt;file_size);
        &#125;
      &#125; else &#123;
        &#x2F;&#x2F; Create concatenating iterator for the files from this level
        list[num++] &#x3D; NewTwoLevelIterator(
            new Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),
            &amp;GetFileIterator, table_cache_, options);
      &#125;
    &#125;
  &#125;
  assert(num &lt;&#x3D; space);
  Iterator* result &#x3D; NewMergingIterator(&amp;icmp_, list, num);
  delete[] list;
  return result;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>compaction过程中另一个要点就是key的drop。对于相同的user_key,首先扫描到的sequence大的，即新的版本。snapshot即为需要压缩到的sequence。<br><code>sequence &gt;=snapshot</code>的所有key需要保留。对于<code>sequence&lt;snapshot</code>的所有key，只保留最大的sequence。如果<code>sequence&lt;snapshot</code>且为sequence最大的key,<br>如果在key的type为删除，并且在之后的所有层中都没有该key，则这个key也可以被删除。这个规则用语言描述很简单直接，但是写成代码确挺绕的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (input-&gt;Valid() &amp;&amp; !shutting_down_.load(std::memory_order_acquire)) &#123;
  &#x2F;&#x2F;......
  Slice key &#x3D; input-&gt;key();
  &#x2F;&#x2F;......

  &#x2F;&#x2F; Handle key&#x2F;value, add to state, etc.
  bool drop &#x3D; false;
  if (!ParseInternalKey(key, &amp;ikey)) &#123;
    &#x2F;&#x2F; Do not hide error keys
    current_user_key.clear();
    has_current_user_key &#x3D; false;
    last_sequence_for_key &#x3D; kMaxSequenceNumber;
  &#125; else &#123;
    if (!has_current_user_key ||
        user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !&#x3D;
            0) &#123;
      &#x2F;&#x2F; First occurrence of this user key
      current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
      has_current_user_key &#x3D; true;
      last_sequence_for_key &#x3D; kMaxSequenceNumber;
    &#125;

    if (last_sequence_for_key &lt;&#x3D; compact-&gt;smallest_snapshot) &#123;
      &#x2F;&#x2F; Hidden by an newer entry for same user key
      drop &#x3D; true;  &#x2F;&#x2F; (A)
    &#125; else if (ikey.type &#x3D;&#x3D; kTypeDeletion &amp;&amp;
               ikey.sequence &lt;&#x3D; compact-&gt;smallest_snapshot &amp;&amp;
               compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;
      &#x2F;&#x2F; For this user key:
      &#x2F;&#x2F; (1) there is no data in higher levels
      &#x2F;&#x2F; (2) data in lower levels will have larger sequence numbers
      &#x2F;&#x2F; (3) data in layers that are being compacted here and have
      &#x2F;&#x2F;     smaller sequence numbers will be dropped in the next
      &#x2F;&#x2F;     few iterations of this loop (by rule (A) above).
      &#x2F;&#x2F; Therefore this deletion marker is obsolete and can be dropped.
      drop &#x3D; true;
    &#125;

    last_sequence_for_key &#x3D; ikey.sequence;
  &#125;
  &#x2F;&#x2F;......

  input-&gt;Next();
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>压缩过程中，受限制于最大文件大小，以及新文件与level+2层重叠范围的大小，可能会生成几个新的sstable文件。当当前文件到达限制时，调用<br><code>FinishCompactionOutputFile</code>生成完整的新文件。最后会将新生成的文件加到Table_Cache中</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
                                          Iterator* input) &#123;
  assert(compact !&#x3D; nullptr);
  assert(compact-&gt;outfile !&#x3D; nullptr);
  assert(compact-&gt;builder !&#x3D; nullptr);

  const uint64_t output_number &#x3D; compact-&gt;current_output()-&gt;number;
  assert(output_number !&#x3D; 0);

  &#x2F;&#x2F; Check for iterator errors
  Status s &#x3D; input-&gt;status();
  const uint64_t current_entries &#x3D; compact-&gt;builder-&gt;NumEntries();
  if (s.ok()) &#123;
    s &#x3D; compact-&gt;builder-&gt;Finish();
  &#125; else &#123;
    compact-&gt;builder-&gt;Abandon();
  &#125;
  const uint64_t current_bytes &#x3D; compact-&gt;builder-&gt;FileSize();
  compact-&gt;current_output()-&gt;file_size &#x3D; current_bytes;
  compact-&gt;total_bytes +&#x3D; current_bytes;
  delete compact-&gt;builder;
  compact-&gt;builder &#x3D; nullptr;

  &#x2F;&#x2F; Finish and check for file errors
  if (s.ok()) &#123;
    s &#x3D; compact-&gt;outfile-&gt;Sync();
  &#125;
  if (s.ok()) &#123;
    s &#x3D; compact-&gt;outfile-&gt;Close();
  &#125;
  delete compact-&gt;outfile;
  compact-&gt;outfile &#x3D; nullptr;

  if (s.ok() &amp;&amp; current_entries &gt; 0) &#123;
    &#x2F;&#x2F; Verify that the table is usable
    Iterator* iter &#x3D;
        table_cache_-&gt;NewIterator(ReadOptions(), output_number, current_bytes);
    s &#x3D; iter-&gt;status();
    delete iter;
    if (s.ok()) &#123;
      Log(options_.info_log, &quot;Generated table #%llu@%d: %lld keys, %lld bytes&quot;,
          (unsigned long long)output_number, compact-&gt;compaction-&gt;level(),
          (unsigned long long)current_entries,
          (unsigned long long)current_bytes);
    &#125;
  &#125;
  return s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件Compaction完成后，生成新的版本</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::InstallCompactionResults(CompactionState* compact) &#123;
  mutex_.AssertHeld();
  Log(options_.info_log, &quot;Compacted %d@%d + %d@%d files &#x3D;&gt; %lld bytes&quot;,
      compact-&gt;compaction-&gt;num_input_files(0), compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1), compact-&gt;compaction-&gt;level() + 1,
      static_cast&lt;long long&gt;(compact-&gt;total_bytes));

  &#x2F;&#x2F; Add compaction outputs
  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());
  const int level &#x3D; compact-&gt;compaction-&gt;level();
  for (size_t i &#x3D; 0; i &lt; compact-&gt;outputs.size(); i++) &#123;
    const CompactionState::Output&amp; out &#x3D; compact-&gt;outputs[i];
    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + 1, out.number, out.file_size,
                                         out.smallest, out.largest);
  &#125;
  return versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>






                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Taria</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tariaunique.github.io/2022/11/24/leveldb_version&compaction/">https://tariaunique.github.io/2022/11/24/leveldb_version&compaction/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Taria</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/11/24/%E6%B7%B7%E6%B7%86ssh/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-11-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Taria
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/11/24/leveldb_sstable/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-11-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Taria
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">Taria</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">13.8k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tariaunique" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:sunya3596@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/tariaunique/cdn@1.1/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
