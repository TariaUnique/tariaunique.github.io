<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/11/24/%E6%B7%B7%E6%B7%86ssh/"/>
      <url>/2022/11/24/%E6%B7%B7%E6%B7%86ssh/</url>
      
        <content type="html"><![CDATA[<p>之前给机子装了混淆ssh，这里记录下网址，免得又忘了当初是怎么装的，干了那些事<a href="http://blog.linjunhalida.com/blog/obfuscated-openssh/">http://blog.linjunhalida.com/blog/obfuscated-openssh/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/leveldb_version&amp;compaction/"/>
      <url>/2022/11/24/leveldb_version&amp;compaction/</url>
      
        <content type="html"><![CDATA[<p>#####version&amp;manifest</p><p>######VersionEdit<br><code>class VersionEdit</code>记录了磁盘每层文件的变更。每次compaction涉及到每层sstable文件的新增和删除，记录到VersionEdit中。同时序列化到manifest文件。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct FileMetaData &#123;  FileMetaData() : refs(0), allowed_seeks(1 &lt;&lt; 30), file_size(0) &#123;&#125;  int refs;  int allowed_seeks;  &#x2F;&#x2F; Seeks allowed until compaction  uint64_t number;  uint64_t file_size;    &#x2F;&#x2F; File size in bytes  InternalKey smallest;  &#x2F;&#x2F; Smallest internal key served by table  InternalKey largest;   &#x2F;&#x2F; Largest internal key served by table&#125;;class VersionEdit &#123; public:  VersionEdit() &#123; Clear(); &#125;  ~VersionEdit() &#x3D; default;  void Clear();  void SetComparatorName(const Slice&amp; name) &#123;    has_comparator_ &#x3D; true;    comparator_ &#x3D; name.ToString();  &#125;  void SetLogNumber(uint64_t num) &#123;     has_log_number_ &#x3D; true;    log_number_ &#x3D; num;  &#125;  void SetPrevLogNumber(uint64_t num) &#123;    has_prev_log_number_ &#x3D; true;    prev_log_number_ &#x3D; num;  &#125;  void SetNextFile(uint64_t num) &#123;    has_next_file_number_ &#x3D; true;    next_file_number_ &#x3D; num;  &#125;  void SetLastSequence(SequenceNumber seq) &#123;    has_last_sequence_ &#x3D; true;    last_sequence_ &#x3D; seq;  &#125;  void SetCompactPointer(int level, const InternalKey&amp; key) &#123;    compact_pointers_.push_back(std::make_pair(level, key));  &#125;  &#x2F;&#x2F; Add the specified file at the specified number.  &#x2F;&#x2F; REQUIRES: This version has not been saved (see VersionSet::SaveTo)  &#x2F;&#x2F; REQUIRES: &quot;smallest&quot; and &quot;largest&quot; are smallest and largest keys in file  void AddFile(int level, uint64_t file, uint64_t file_size,               const InternalKey&amp; smallest, const InternalKey&amp; largest) &#123;    FileMetaData f;    f.number &#x3D; file;    f.file_size &#x3D; file_size;    f.smallest &#x3D; smallest;    f.largest &#x3D; largest;    new_files_.push_back(std::make_pair(level, f));  &#125;  &#x2F;&#x2F; Delete the specified &quot;file&quot; from the specified &quot;level&quot;.  void RemoveFile(int level, uint64_t file) &#123;    deleted_files_.insert(std::make_pair(level, file));  &#125;  void EncodeTo(std::string* dst) const;  Status DecodeFrom(const Slice&amp; src);  std::string DebugString() const; private:  friend class VersionSet;  typedef std::set&lt;std::pair&lt;int, uint64_t&gt;&gt; DeletedFileSet;  std::string comparator_;  uint64_t log_number_;  uint64_t prev_log_number_;  uint64_t next_file_number_;  SequenceNumber last_sequence_;  bool has_comparator_;  bool has_log_number_;  bool has_prev_log_number_;  bool has_next_file_number_;  bool has_last_sequence_;  std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;  DeletedFileSet deleted_files_;  std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要的文件变更记录到new_files_和deleted_files_中。</p><p>######Version<br><code>class Version</code>为磁盘文件的某一个版本。主要记录了每层的sstable的FileMetaData。版本的变更连接为双层链表。同时该类封装了从该版本查找数据的接口。DB的Get操作，查找到sstable时，入口是Version::Get()。<br>除此之外，每次compaction时，所需的compaction信息也是从当前的version获得。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LookupKey lkey(key, snapshot);if (mem-&gt;Get(lkey, value, &amp;s)) &#123;  &#x2F;&#x2F; Done&#125; else if (imm !&#x3D; nullptr &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;  &#x2F;&#x2F; Done&#125; else &#123;  s &#x3D; current-&gt;Get(options, lkey, value, &amp;stats);  have_stat_update &#x3D; true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Version的主要数据成员如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Version &#123;private:  VersionSet* vset_;  &#x2F;&#x2F; VersionSet to which this Version belongs  Version* next_;     &#x2F;&#x2F; Next version in linked list  Version* prev_;     &#x2F;&#x2F; Previous version in linked list  int refs_;          &#x2F;&#x2F; Number of live refs to this version  &#x2F;&#x2F; List of files per level  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];  &#x2F;&#x2F; Next file to compact based on seek stats.  FileMetaData* file_to_compact_;  int file_to_compact_level_;  &#x2F;&#x2F; Level that should be compacted next and its compaction score.  &#x2F;&#x2F; Score &lt; 1 means compaction is not strictly needed.  These fields  &#x2F;&#x2F; are initialized by Finalize().  double compaction_score_;  int compaction_level_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当immutable memtable 需要压缩时，首先将immemtable序列化到新的sstable中。使用memtable 的迭代器按序读取，并使用TableBuilder 的Add()。<br>在序列化的过程中，不持有锁。所以别的线程可以读取immemtable。序列化完成后，磁盘存入新的sstable,meta记录sstable的FileMetaData。同时,<br>table_cache_调用Table::Open()打开这个新生成的sstale,存入Table_Cache缓存中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,                                Version* base) &#123;  mutex_.AssertHeld();  const uint64_t start_micros &#x3D; env_-&gt;NowMicros();  FileMetaData meta;  meta.number &#x3D; versions_-&gt;NewFileNumber();  pending_outputs_.insert(meta.number);  Iterator* iter &#x3D; mem-&gt;NewIterator();  Log(options_.info_log, &quot;Level-0 table #%llu: started&quot;,      (unsigned long long)meta.number);  Status s;  &#123;    mutex_.Unlock();    s &#x3D; BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);    mutex_.Lock();  &#125;   &#x2F;&#x2F;.....&#125;Status BuildTable(const std::string&amp; dbname, Env* env, const Options&amp; options,                  TableCache* table_cache, Iterator* iter, FileMetaData* meta) &#123;    &#x2F;&#x2F;......使用TableBuilder序列化key,value 到新的sstable中    &#x2F;&#x2F; Finish and check for file errors    if (s.ok()) &#123;      s &#x3D; file-&gt;Sync();    &#125;    if (s.ok()) &#123;      s &#x3D; file-&gt;Close();    &#125;    delete file;    file &#x3D; nullptr;    if (s.ok()) &#123;      &#x2F;&#x2F; Verify that the table is usable      &#x2F;&#x2F;这一步会打开新生成的sstable，加入缓存      Iterator* it &#x3D; table_cache-&gt;NewIterator(ReadOptions(), meta-&gt;number,                                              meta-&gt;file_size);      s &#x3D; it-&gt;status();      delete it;    &#125;    &#x2F;&#x2F;......&#125;现在磁盘多了一个sstable文件，需要决定将它放入level0还是更高的level中。调用version的PickLevelForMemTableOutput接口。具体规则为，如果新的sstable的key范围跟level1所有文件不重叠，并且，跟level2重叠的文件大小不超过10*max_file_size。即重叠不超过10个文件，则可以直接放到level1中。同规则适应到level2。最多存放到level2中.这个push规则，即减少了level0 sstables的数量。同时，也不至于push的level太高了影响读取。level0 sstable的数量如果过多，会影响到写入的延迟。当push的level决定之后，就将修改写入edit中。这里只有新增文件，记录到edit的new_files_中。&#96;&#96;&#96;c++Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,                                Version* base) &#123;  &#x2F;&#x2F;......  &#x2F;&#x2F; Note that if file_size is zero, the file has been deleted and  &#x2F;&#x2F; should not be added to the manifest.  int level &#x3D; 0;  if (s.ok() &amp;&amp; meta.file_size &gt; 0) &#123;    const Slice min_user_key &#x3D; meta.smallest.user_key();    const Slice max_user_key &#x3D; meta.largest.user_key();    if (base !&#x3D; nullptr) &#123;      level &#x3D; base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);    &#125;    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,                  meta.largest);  &#125;  &#x2F;&#x2F;......&#125;int Version::PickLevelForMemTableOutput(const Slice&amp; smallest_user_key,                                        const Slice&amp; largest_user_key) &#123;  int level &#x3D; 0;  if (!OverlapInLevel(0, &amp;smallest_user_key, &amp;largest_user_key)) &#123;    &#x2F;&#x2F; Push to next level if there is no overlap in next level,    &#x2F;&#x2F; and the #bytes overlapping in the level after that are limited.    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));    std::vector&lt;FileMetaData*&gt; overlaps;    while (level &lt; config::kMaxMemCompactLevel) &#123;      if (OverlapInLevel(level + 1, &amp;smallest_user_key, &amp;largest_user_key)) &#123;        break;      &#125;      if (level + 2 &lt; config::kNumLevels) &#123;        &#x2F;&#x2F; Check that file does not overlap too many grandparent bytes.        GetOverlappingInputs(level + 2, &amp;start, &amp;limit, &amp;overlaps);        const int64_t sum &#x3D; TotalFileSize(overlaps);        if (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;          break;        &#125;      &#125;      level++;    &#125;  &#125;  return level;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后immemtable 的wal文件可以被删除。首先将新版本的prev_log_number置为0，记录到edit中，表示wal log的变更。<br>然后调用VersionSet::LogAndApply(),其中调用Builder::Apply(), Builder::SaveTo()生成新的version，同时将edit写入manifest文件中。如果manifest文件之前为空，需要<br>将current_ version 转化为edit,写入初始的edit，然后将新增的edit写入manifest。最后应用新的version.即将version连入链表，并将current_指向新的version.<br>最后删除prev wal log 文件。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DBImpl::CompactMemTable() &#123;    &#x2F;&#x2F;......  if (s.ok()) &#123;    edit.SetPrevLogNumber(0);    edit.SetLogNumber(logfile_number_);  &#x2F;&#x2F; Earlier logs no longer needed    s &#x3D; versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);  &#125;  if (s.ok()) &#123;    &#x2F;&#x2F; Commit to the new state    imm_-&gt;Unref();    imm_ &#x3D; nullptr;    has_imm_.store(false, std::memory_order_release);    RemoveObsoleteFiles();  &#125;  &#x2F;&#x2F;.......&#125;Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;  if (edit-&gt;has_log_number_) &#123;    assert(edit-&gt;log_number_ &gt;&#x3D; log_number_);    assert(edit-&gt;log_number_ &lt; next_file_number_);  &#125; else &#123;    edit-&gt;SetLogNumber(log_number_);  &#125;  if (!edit-&gt;has_prev_log_number_) &#123;    edit-&gt;SetPrevLogNumber(prev_log_number_);  &#125;  edit-&gt;SetNextFile(next_file_number_);  edit-&gt;SetLastSequence(last_sequence_);  Version* v &#x3D; new Version(this);  &#123;    Builder builder(this, current_);    builder.Apply(edit);    builder.SaveTo(v);  &#125;  Finalize(v); &#x2F;&#x2F;这里主要时计算新的version的compaction 信息，暂时略过  &#x2F;&#x2F; Initialize new descriptor log file if necessary by creating  &#x2F;&#x2F; a temporary file that contains a snapshot of the current version.  std::string new_manifest_file;  Status s;  if (descriptor_log_ &#x3D;&#x3D; nullptr) &#123;    &#x2F;&#x2F; No reason to unlock *mu here since we only hit this path in the    &#x2F;&#x2F; first call to LogAndApply (when opening the database).    assert(descriptor_file_ &#x3D;&#x3D; nullptr);    new_manifest_file &#x3D; DescriptorFileName(dbname_, manifest_file_number_);    edit-&gt;SetNextFile(next_file_number_);    s &#x3D; env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);    if (s.ok()) &#123;      descriptor_log_ &#x3D; new log::Writer(descriptor_file_);      s &#x3D; WriteSnapshot(descriptor_log_); &#x2F;&#x2F;将当前version转为edit存入新的manifest文件。    &#125;  &#125;  &#x2F;&#x2F; Unlock during expensive MANIFEST log write  &#123;    mu-&gt;Unlock();    &#x2F;&#x2F; Write new record to MANIFEST log    if (s.ok()) &#123;      std::string record;      edit-&gt;EncodeTo(&amp;record);      s &#x3D; descriptor_log_-&gt;AddRecord(record);      if (s.ok()) &#123;        s &#x3D; descriptor_file_-&gt;Sync();      &#125;      if (!s.ok()) &#123;        Log(options_-&gt;info_log, &quot;MANIFEST write: %s\n&quot;, s.ToString().c_str());      &#125;    &#125;    &#x2F;&#x2F; If we just created a new descriptor file, install it by writing a    &#x2F;&#x2F; new CURRENT file that points to it.    if (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;      s &#x3D; SetCurrentFile(env_, dbname_, manifest_file_number_);    &#125;    mu-&gt;Lock();  &#125;  &#x2F;&#x2F; Install the new version  if (s.ok()) &#123;    AppendVersion(v);    log_number_ &#x3D; edit-&gt;log_number_;    prev_log_number_ &#x3D; edit-&gt;prev_log_number_;  &#125; else &#123;    delete v;    if (!new_manifest_file.empty()) &#123;      delete descriptor_log_;      delete descriptor_file_;      descriptor_log_ &#x3D; nullptr;      descriptor_file_ &#x3D; nullptr;      env_-&gt;RemoveFile(new_manifest_file);    &#125;  &#125;  return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class VersionSet::Builder 根据前一个Version版本，以及新版本的VersionEdit变更记录，生成新的Version<br>数据成员如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A helper class so we can efficiently apply a whole sequence&#x2F;&#x2F; of edits to a particular state without creating intermediate&#x2F;&#x2F; Versions that contain full copies of the intermediate state.class VersionSet::Builder &#123; private:  &#x2F;&#x2F; Helper to sort by v-&gt;files_[file_number].smallest  struct BySmallestKey &#123;    const InternalKeyComparator* internal_comparator;    bool operator()(FileMetaData* f1, FileMetaData* f2) const &#123;      int r &#x3D; internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);      if (r !&#x3D; 0) &#123;        return (r &lt; 0);      &#125; else &#123;        &#x2F;&#x2F; Break ties by file number        return (f1-&gt;number &lt; f2-&gt;number);      &#125;    &#125;  &#125;;  typedef std::set&lt;FileMetaData*, BySmallestKey&gt; FileSet;  struct LevelState &#123;    std::set&lt;uint64_t&gt; deleted_files;    FileSet* added_files;  &#125;;  VersionSet* vset_;  Version* base_;  LevelState levels_[config::kNumLevels];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要操作为Apply和SaveTo</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Apply(VersionEdit* edit) &#123;  &#x2F;&#x2F; Update compaction pointers  for (size_t i &#x3D; 0; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;    const int level &#x3D; edit-&gt;compact_pointers_[i].first;    vset_-&gt;compact_pointer_[level] &#x3D;        edit-&gt;compact_pointers_[i].second.Encode().ToString();  &#125;  &#x2F;&#x2F; Delete files  for (const auto&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;    const int level &#x3D; deleted_file_set_kvp.first;    const uint64_t number &#x3D; deleted_file_set_kvp.second;    levels_[level].deleted_files.insert(number);  &#125;  &#x2F;&#x2F; Add new files  for (size_t i &#x3D; 0; i &lt; edit-&gt;new_files_.size(); i++) &#123;    const int level &#x3D; edit-&gt;new_files_[i].first;    FileMetaData* f &#x3D; new FileMetaData(edit-&gt;new_files_[i].second);    f-&gt;refs &#x3D; 1;    &#x2F;&#x2F;....    levels_[level].deleted_files.erase(f-&gt;number);    levels_[level].added_files-&gt;insert(f);  &#125;&#125;  &#x2F;&#x2F; Save the current state in *v.void SaveTo(Version* v) &#123;  BySmallestKey cmp;  cmp.internal_comparator &#x3D; &amp;vset_-&gt;icmp_;  for (int level &#x3D; 0; level &lt; config::kNumLevels; level++) &#123;    &#x2F;&#x2F; Merge the set of added files with the set of pre-existing files.    &#x2F;&#x2F; Drop any deleted files.  Store the result in *v.    const std::vector&lt;FileMetaData*&gt;&amp; base_files &#x3D; base_-&gt;files_[level];    std::vector&lt;FileMetaData*&gt;::const_iterator base_iter &#x3D; base_files.begin();    std::vector&lt;FileMetaData*&gt;::const_iterator base_end &#x3D; base_files.end();    const FileSet* added_files &#x3D; levels_[level].added_files;    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());    for (const auto&amp; added_file : *added_files) &#123;      &#x2F;&#x2F; Add all smaller files listed in base_      for (std::vector&lt;FileMetaData*&gt;::const_iterator bpos &#x3D;               std::upper_bound(base_iter, base_end, added_file, cmp);           base_iter !&#x3D; bpos; ++base_iter) &#123;        MaybeAddFile(v, level, *base_iter); &#x2F;&#x2F;MaybeAddFile：如果该文件被删除，则不添加。      &#125;      MaybeAddFile(v, level, added_file);    &#125;    &#x2F;&#x2F; Add remaining base files    for (; base_iter !&#x3D; base_end; ++base_iter) &#123;      MaybeAddFile(v, level, *base_iter);    &#125;    &#x2F;&#x2F;....  &#125;&#125;void MaybeAddFile(Version* v, int level, FileMetaData* f) &#123;  if (levels_[level].deleted_files.count(f-&gt;number) &gt; 0) &#123;    &#x2F;&#x2F; File is deleted: do nothing  &#125; else &#123;    std::vector&lt;FileMetaData*&gt;* files &#x3D; &amp;v-&gt;files_[level];    if (level &gt; 0 &amp;&amp; !files-&gt;empty()) &#123;      &#x2F;&#x2F; Must not overlap      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - 1]-&gt;largest,                                  f-&gt;smallest) &lt; 0);    &#125;    f-&gt;refs++;    files-&gt;push_back(f);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>######sstable compaction<br>sstable compaction 的触发条件主要由两个，其一是根据各层文件大小和数量决定是否compaction,以及compact哪一层sstable。这个判断条件在每生成新的version时计算值。<br>对于level0,只判断sstables数量。<br>level1-7 compaction 总大小为10M,10*10M….<br><code>Version::compaction_level_</code>和<code>Version::compaction_score</code>在新version生成时计算(也即磁盘文件的一次compact后)，在该version生效期间保持不变，直到下一个version生成。<br>很有可能一个verison刚生成，他的compaction_score 就已经大于1了，比如，immutable memtable-&gt;level0 sstable，使得level0的sstables文件数量超过4个，新生成的version，score&gt;1,level为0<br>或者前一个compaction导致下层的文件大小超过压缩限制，也会触发下一层compaction。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void VersionSet::Finalize(Version* v) &#123;  &#x2F;&#x2F; Precomputed best level for next compaction  int best_level &#x3D; -1;  double best_score &#x3D; -1;  for (int level &#x3D; 0; level &lt; config::kNumLevels - 1; level++) &#123;    double score;    if (level &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F; We treat level-0 specially by bounding the number of files      &#x2F;&#x2F; instead of number of bytes for two reasons:      &#x2F;&#x2F;      &#x2F;&#x2F; (1) With larger write-buffer sizes, it is nice not to do too      &#x2F;&#x2F; many level-0 compactions.      &#x2F;&#x2F;      &#x2F;&#x2F; (2) The files in level-0 are merged on every read and      &#x2F;&#x2F; therefore we wish to avoid too many files when the individual      &#x2F;&#x2F; file size is small (perhaps because of a small write-buffer      &#x2F;&#x2F; setting, or very high compression ratios, or lots of      &#x2F;&#x2F; overwrites&#x2F;deletions).      score &#x3D; v-&gt;files_[level].size() &#x2F;              static_cast&lt;double&gt;(config::kL0_CompactionTrigger);    &#125; else &#123;      &#x2F;&#x2F; Compute the ratio of current size to size limit.      const uint64_t level_bytes &#x3D; TotalFileSize(v-&gt;files_[level]);      score &#x3D;          static_cast&lt;double&gt;(level_bytes) &#x2F; MaxBytesForLevel(options_, level);    &#125;    if (score &gt; best_score) &#123;      best_level &#x3D; level;      best_score &#x3D; score;    &#125;  &#125;  v-&gt;compaction_level_ &#x3D; best_level;  v-&gt;compaction_score_ &#x3D; best_score;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个触发条件为Get操作，查询到sstable，某个文件被查询，却没有找到。每个sstable在生成时会有allowed_seek属性。<br>默认为文件大小除以12kb。该属性表示被seek，却没有找到的次数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Builder::Apply()&#123;    &#x2F;&#x2F;......    &#x2F;&#x2F; Add new files    for (size_t i &#x3D; 0; i &lt; edit-&gt;new_files_.size(); i++) &#123;      const int level &#x3D; edit-&gt;new_files_[i].first;      FileMetaData* f &#x3D; new FileMetaData(edit-&gt;new_files_[i].second);      f-&gt;refs &#x3D; 1;      &#x2F;&#x2F; We arrange to automatically compact this file after      &#x2F;&#x2F; a certain number of seeks.  Let&#39;s assume:      &#x2F;&#x2F;   (1) One seek costs 10ms      &#x2F;&#x2F;   (2) Writing or reading 1MB costs 10ms (100MB&#x2F;s)      &#x2F;&#x2F;   (3) A compaction of 1MB does 25MB of IO:      &#x2F;&#x2F;         1MB read from this level      &#x2F;&#x2F;         10-12MB read from next level (boundaries may be misaligned)      &#x2F;&#x2F;         10-12MB written to next level      &#x2F;&#x2F; This implies that 25 seeks cost the same as the compaction      &#x2F;&#x2F; of 1MB of data.  I.e., one seek costs approximately the      &#x2F;&#x2F; same as the compaction of 40KB of data.  We are a little      &#x2F;&#x2F; conservative and allow approximately one seek for every 16KB      &#x2F;&#x2F; of data before triggering a compaction.      f-&gt;allowed_seeks &#x3D; static_cast&lt;int&gt;((f-&gt;file_size &#x2F; 16384U));      if (f-&gt;allowed_seeks &lt; 100) f-&gt;allowed_seeks &#x3D; 100;      levels_[level].deleted_files.erase(f-&gt;number);      levels_[level].added_files-&gt;insert(f);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>VersionSet::PickCompaction()</code>设置好需要compact的两层sstables,以及其他相关的compact信息到Compaction中，<br>实际压缩时，根据Compaction中的信息进行压缩。<br>如果的文件大小或者数量超过限制，则levelL层压缩文件的选择从上次compact_point开始，如果为0层，需要找到所有与之重叠的范围。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Compaction* VersionSet::PickCompaction() &#123;  Compaction* c;  int level;  &#x2F;&#x2F; We prefer compactions triggered by too much data in a level over  &#x2F;&#x2F; the compactions triggered by seeks.  const bool size_compaction &#x3D; (current_-&gt;compaction_score_ &gt;&#x3D; 1);  const bool seek_compaction &#x3D; (current_-&gt;file_to_compact_ !&#x3D; nullptr);  if (size_compaction) &#123;    level &#x3D; current_-&gt;compaction_level_;    assert(level &gt;&#x3D; 0);    assert(level + 1 &lt; config::kNumLevels);    c &#x3D; new Compaction(options_, level);    &#x2F;&#x2F; Pick the first file that comes after compact_pointer_[level]    for (size_t i &#x3D; 0; i &lt; current_-&gt;files_[level].size(); i++) &#123;      FileMetaData* f &#x3D; current_-&gt;files_[level][i];      if (compact_pointer_[level].empty() ||          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; 0) &#123;        c-&gt;inputs_[0].push_back(f);        break;      &#125;    &#125;    if (c-&gt;inputs_[0].empty()) &#123;      &#x2F;&#x2F; Wrap-around to the beginning of the key space      c-&gt;inputs_[0].push_back(current_-&gt;files_[level][0]);    &#125;  &#125; else if (seek_compaction) &#123;    level &#x3D; current_-&gt;file_to_compact_level_;    c &#x3D; new Compaction(options_, level);    c-&gt;inputs_[0].push_back(current_-&gt;file_to_compact_);  &#125; else &#123;    return nullptr;  &#125;  c-&gt;input_version_ &#x3D; current_;  c-&gt;input_version_-&gt;Ref();  &#x2F;&#x2F; Files in level 0 may overlap each other, so pick up all overlapping ones  if (level &#x3D;&#x3D; 0) &#123;    InternalKey smallest, largest;    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);    &#x2F;&#x2F; Note that the next call will discard the file we placed in    &#x2F;&#x2F; c-&gt;inputs_[0] earlier and replace it with an overlapping set    &#x2F;&#x2F; which will include the picked file.    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);    assert(!c-&gt;inputs_[0].empty());  &#125;  SetupOtherInputs(c);  return c;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中Version::GetOverlappingInputs()函数对level0层重叠范围文件的查询有特殊操作。<br>对其他层文件，只需要一个一个判断有没有重叠。对level0层，当找到一个重叠文件后，需要看是否扩大了范围。<br>注意这里判断overlap比较的是userkey而不是interkey。同时这里只对level0生效。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Version::GetOverlappingInputs(int level, const InternalKey* begin,                                   const InternalKey* end,                                   std::vector&lt;FileMetaData*&gt;* inputs) &#123;  assert(level &gt;&#x3D; 0);  assert(level &lt; config::kNumLevels);  inputs-&gt;clear();  Slice user_begin, user_end;  if (begin !&#x3D; nullptr) &#123;    user_begin &#x3D; begin-&gt;user_key();  &#125;  if (end !&#x3D; nullptr) &#123;    user_end &#x3D; end-&gt;user_key();  &#125;  const Comparator* user_cmp &#x3D; vset_-&gt;icmp_.user_comparator();  for (size_t i &#x3D; 0; i &lt; files_[level].size();) &#123;    FileMetaData* f &#x3D; files_[level][i++];    const Slice file_start &#x3D; f-&gt;smallest.user_key();    const Slice file_limit &#x3D; f-&gt;largest.user_key();    if (begin !&#x3D; nullptr &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; 0) &#123;      &#x2F;&#x2F; &quot;f&quot; is completely before specified range; skip it    &#125; else if (end !&#x3D; nullptr &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; 0) &#123;      &#x2F;&#x2F; &quot;f&quot; is completely after specified range; skip it    &#125; else &#123;      inputs-&gt;push_back(f);      if (level &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; Level-0 files may overlap each other.  So check if the newly        &#x2F;&#x2F; added file has expanded the range.  If so, restart search.        if (begin !&#x3D; nullptr &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; 0) &#123;          user_begin &#x3D; file_start;          inputs-&gt;clear();          i &#x3D; 0;        &#125; else if (end !&#x3D; nullptr &amp;&amp;                   user_cmp-&gt;Compare(file_limit, user_end) &gt; 0) &#123;          user_end &#x3D; file_limit;          inputs-&gt;clear();          i &#x3D; 0;        &#125;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Version::SetupOtherInputs()</code>主要设置level+1层压缩文件。<br>首先对于之前获取的level层文件，需要扩展其boundary 文件，所谓boundary files就是其最小的key&gt;input[0]所有文件key范围最大的key,但是其user_key相等。<br>这在level&gt;0是完全有可能的。同时这样的边界文件可能不止一个。具体代码见<code>AddBoundaryInputs</code>。同时，对于level0层文件，是不会有边界拓展的，因为level0层文件的overlap判断就是以user_key为判断条件的。<br>根据扩展后的level 层文件范围，获取level+1层文件，同时检查level+1层的边界文件。<br>level+1层的文件范围可能大于level层，再去level层判断会不会有包含在level+1层范围之内的文件……<br>总之这段代码就是尽量多的扩展压缩范围，同时保证压缩的所有文件大小小于25*max_file_size。<br>最后记录下范围重叠的level+2层文件，更新compaction_point.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void VersionSet::SetupOtherInputs(Compaction* c) &#123;  const int level &#x3D; c-&gt;level();  InternalKey smallest, largest;  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[0]);  GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);  current_-&gt;GetOverlappingInputs(level + 1, &amp;smallest, &amp;largest,                                 &amp;c-&gt;inputs_[1]);  AddBoundaryInputs(icmp_, current_-&gt;files_[level + 1], &amp;c-&gt;inputs_[1]);  &#x2F;&#x2F; Get entire range covered by compaction  InternalKey all_start, all_limit;  GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);  &#x2F;&#x2F; See if we can grow the number of inputs in &quot;level&quot; without  &#x2F;&#x2F; changing the number of &quot;level+1&quot; files we pick up.  if (!c-&gt;inputs_[1].empty()) &#123;    std::vector&lt;FileMetaData*&gt; expanded0;    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);    const int64_t inputs0_size &#x3D; TotalFileSize(c-&gt;inputs_[0]);    const int64_t inputs1_size &#x3D; TotalFileSize(c-&gt;inputs_[1]);    const int64_t expanded0_size &#x3D; TotalFileSize(expanded0);    if (expanded0.size() &gt; c-&gt;inputs_[0].size() &amp;&amp;        inputs1_size + expanded0_size &lt;            ExpandedCompactionByteSizeLimit(options_)) &#123;      InternalKey new_start, new_limit;      GetRange(expanded0, &amp;new_start, &amp;new_limit);      std::vector&lt;FileMetaData*&gt; expanded1;      current_-&gt;GetOverlappingInputs(level + 1, &amp;new_start, &amp;new_limit,                                     &amp;expanded1);      AddBoundaryInputs(icmp_, current_-&gt;files_[level + 1], &amp;expanded1);      if (expanded1.size() &#x3D;&#x3D; c-&gt;inputs_[1].size()) &#123;        Log(options_-&gt;info_log,            &quot;Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n&quot;,            level, int(c-&gt;inputs_[0].size()), int(c-&gt;inputs_[1].size()),            long(inputs0_size), long(inputs1_size), int(expanded0.size()),            int(expanded1.size()), long(expanded0_size), long(inputs1_size));        smallest &#x3D; new_start;        largest &#x3D; new_limit;        c-&gt;inputs_[0] &#x3D; expanded0;        c-&gt;inputs_[1] &#x3D; expanded1;        GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);      &#125;    &#125;  &#125;  &#x2F;&#x2F; Compute the set of grandparent files that overlap this compaction  &#x2F;&#x2F; (parent &#x3D;&#x3D; level+1; grandparent &#x3D;&#x3D; level+2)  if (level + 2 &lt; config::kNumLevels) &#123;    current_-&gt;GetOverlappingInputs(level + 2, &amp;all_start, &amp;all_limit,                                   &amp;c-&gt;grandparents_);  &#125;  &#x2F;&#x2F; Update the place where we will do the next compaction for this level.  &#x2F;&#x2F; We update this immediately instead of waiting for the VersionEdit  &#x2F;&#x2F; to be applied so that if the compaction fails, we will try a different  &#x2F;&#x2F; key range next time.  compact_pointer_[level] &#x3D; largest.Encode().ToString();  c-&gt;edit_.SetCompactPointer(level, largest);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的压缩操作主要就是生成MergeIterator,从小到大遍历所有的key,根据snapshot，去掉相应的overwritten和删除的key。</p><p>首先看下MergeIterator。MergeIterator就是多个迭代器的封装。其Seek操作，为每个迭代器都Seek，<br>取其指向最小的迭代器，作为current_迭代器。其Next()操作，current_++，再取其所有迭代器指向的key最小的迭代器作为current_。<br>对于需要压缩的<code>std::vector&lt;FileMetaData*&gt; inputs_[2]</code>,如果inputs_[0]所压缩的文件为level 0 层文件，则Merge迭代器中children_数量为inputs[0].size()+1,<br>每个level0 层sstable一个Table::Iterator。level 1层文件一个二级迭代器，第一级遍历<code>vector&lt;FileMetaData*&gt;</code>数组，第二级遍历相应的文件。<br>如果inputs_[0]所压缩的level不为第0层，则MergeIterator中children_迭代器为两个，为每层的二级迭代器。其原因无非就是，level0层文件之前有重叠，不是整体有序的。<br>MergeIterator</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MergingIterator : public Iterator &#123; public:  MergingIterator(const Comparator* comparator, Iterator** children, int n)      : comparator_(comparator),        children_(new IteratorWrapper[n]),        n_(n),        current_(nullptr),        direction_(kForward) &#123;    for (int i &#x3D; 0; i &lt; n; i++) &#123;      children_[i].Set(children[i]);    &#125;  &#125;  ~MergingIterator() override &#123; delete[] children_; &#125;  bool Valid() const override &#123; return (current_ !&#x3D; nullptr); &#125;  void SeekToFirst() override &#123;    for (int i &#x3D; 0; i &lt; n_; i++) &#123;      children_[i].SeekToFirst();    &#125;    FindSmallest();    direction_ &#x3D; kForward;  &#125;  void SeekToLast() override &#123;    for (int i &#x3D; 0; i &lt; n_; i++) &#123;      children_[i].SeekToLast();    &#125;    FindLargest();    direction_ &#x3D; kReverse;  &#125;  void Seek(const Slice&amp; target) override &#123;    for (int i &#x3D; 0; i &lt; n_; i++) &#123;      children_[i].Seek(target);    &#125;    FindSmallest();    direction_ &#x3D; kForward;  &#125;  void Next() override &#123;    assert(Valid());    &#x2F;&#x2F; Ensure that all children are positioned after key().    &#x2F;&#x2F; If we are moving in the forward direction, it is already    &#x2F;&#x2F; true for all of the non-current_ children since current_ is    &#x2F;&#x2F; the smallest child and key() &#x3D;&#x3D; current_-&gt;key().  Otherwise,    &#x2F;&#x2F; we explicitly position the non-current_ children.    if (direction_ !&#x3D; kForward) &#123;      for (int i &#x3D; 0; i &lt; n_; i++) &#123;        IteratorWrapper* child &#x3D; &amp;children_[i];        if (child !&#x3D; current_) &#123;          child-&gt;Seek(key());          if (child-&gt;Valid() &amp;&amp;              comparator_-&gt;Compare(key(), child-&gt;key()) &#x3D;&#x3D; 0) &#123;            child-&gt;Next();          &#125;        &#125;      &#125;      direction_ &#x3D; kForward;    &#125;    current_-&gt;Next();    FindSmallest();  &#125;&#x2F;&#x2F;......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>MakeInputIterator</code>根据input_生成MergeIterator。fill_cache为false,即Iterator访问的Block不缓存。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Iterator* VersionSet::MakeInputIterator(Compaction* c) &#123;  ReadOptions options;  options.verify_checksums &#x3D; options_-&gt;paranoid_checks;  options.fill_cache &#x3D; false;  &#x2F;&#x2F; Level-0 files have to be merged together.  For other levels,  &#x2F;&#x2F; we will make a concatenating iterator per level.  &#x2F;&#x2F; TODO(opt): use concatenating iterator for level-0 if there is no overlap  const int space &#x3D; (c-&gt;level() &#x3D;&#x3D; 0 ? c-&gt;inputs_[0].size() + 1 : 2);  Iterator** list &#x3D; new Iterator*[space];  int num &#x3D; 0;  for (int which &#x3D; 0; which &lt; 2; which++) &#123;    if (!c-&gt;inputs_[which].empty()) &#123;      if (c-&gt;level() + which &#x3D;&#x3D; 0) &#123;        const std::vector&lt;FileMetaData*&gt;&amp; files &#x3D; c-&gt;inputs_[which];        for (size_t i &#x3D; 0; i &lt; files.size(); i++) &#123;          list[num++] &#x3D; table_cache_-&gt;NewIterator(options, files[i]-&gt;number,                                                  files[i]-&gt;file_size);        &#125;      &#125; else &#123;        &#x2F;&#x2F; Create concatenating iterator for the files from this level        list[num++] &#x3D; NewTwoLevelIterator(            new Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),            &amp;GetFileIterator, table_cache_, options);      &#125;    &#125;  &#125;  assert(num &lt;&#x3D; space);  Iterator* result &#x3D; NewMergingIterator(&amp;icmp_, list, num);  delete[] list;  return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>compaction过程中另一个要点就是key的drop。对于相同的user_key,首先扫描到的sequence大的，即新的版本。snapshot即为需要压缩到的sequence。<br><code>sequence &gt;=snapshot</code>的所有key需要保留。对于<code>sequence&lt;snapshot</code>的所有key，只保留最大的sequence。如果<code>sequence&lt;snapshot</code>且为sequence最大的key,<br>如果在key的type为删除，并且在之后的所有层中都没有该key，则这个key也可以被删除。这个规则用语言描述很简单直接，但是写成代码确挺绕的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (input-&gt;Valid() &amp;&amp; !shutting_down_.load(std::memory_order_acquire)) &#123;  &#x2F;&#x2F;......  Slice key &#x3D; input-&gt;key();  &#x2F;&#x2F;......  &#x2F;&#x2F; Handle key&#x2F;value, add to state, etc.  bool drop &#x3D; false;  if (!ParseInternalKey(key, &amp;ikey)) &#123;    &#x2F;&#x2F; Do not hide error keys    current_user_key.clear();    has_current_user_key &#x3D; false;    last_sequence_for_key &#x3D; kMaxSequenceNumber;  &#125; else &#123;    if (!has_current_user_key ||        user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !&#x3D;            0) &#123;      &#x2F;&#x2F; First occurrence of this user key      current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());      has_current_user_key &#x3D; true;      last_sequence_for_key &#x3D; kMaxSequenceNumber;    &#125;    if (last_sequence_for_key &lt;&#x3D; compact-&gt;smallest_snapshot) &#123;      &#x2F;&#x2F; Hidden by an newer entry for same user key      drop &#x3D; true;  &#x2F;&#x2F; (A)    &#125; else if (ikey.type &#x3D;&#x3D; kTypeDeletion &amp;&amp;               ikey.sequence &lt;&#x3D; compact-&gt;smallest_snapshot &amp;&amp;               compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;      &#x2F;&#x2F; For this user key:      &#x2F;&#x2F; (1) there is no data in higher levels      &#x2F;&#x2F; (2) data in lower levels will have larger sequence numbers      &#x2F;&#x2F; (3) data in layers that are being compacted here and have      &#x2F;&#x2F;     smaller sequence numbers will be dropped in the next      &#x2F;&#x2F;     few iterations of this loop (by rule (A) above).      &#x2F;&#x2F; Therefore this deletion marker is obsolete and can be dropped.      drop &#x3D; true;    &#125;    last_sequence_for_key &#x3D; ikey.sequence;  &#125;  &#x2F;&#x2F;......  input-&gt;Next();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>压缩过程中，受限制于最大文件大小，以及新文件与level+2层重叠范围的大小，可能会生成几个新的sstable文件。当当前文件到达限制时，调用<br><code>FinishCompactionOutputFile</code>生成完整的新文件。最后会将新生成的文件加到Table_Cache中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,                                          Iterator* input) &#123;  assert(compact !&#x3D; nullptr);  assert(compact-&gt;outfile !&#x3D; nullptr);  assert(compact-&gt;builder !&#x3D; nullptr);  const uint64_t output_number &#x3D; compact-&gt;current_output()-&gt;number;  assert(output_number !&#x3D; 0);  &#x2F;&#x2F; Check for iterator errors  Status s &#x3D; input-&gt;status();  const uint64_t current_entries &#x3D; compact-&gt;builder-&gt;NumEntries();  if (s.ok()) &#123;    s &#x3D; compact-&gt;builder-&gt;Finish();  &#125; else &#123;    compact-&gt;builder-&gt;Abandon();  &#125;  const uint64_t current_bytes &#x3D; compact-&gt;builder-&gt;FileSize();  compact-&gt;current_output()-&gt;file_size &#x3D; current_bytes;  compact-&gt;total_bytes +&#x3D; current_bytes;  delete compact-&gt;builder;  compact-&gt;builder &#x3D; nullptr;  &#x2F;&#x2F; Finish and check for file errors  if (s.ok()) &#123;    s &#x3D; compact-&gt;outfile-&gt;Sync();  &#125;  if (s.ok()) &#123;    s &#x3D; compact-&gt;outfile-&gt;Close();  &#125;  delete compact-&gt;outfile;  compact-&gt;outfile &#x3D; nullptr;  if (s.ok() &amp;&amp; current_entries &gt; 0) &#123;    &#x2F;&#x2F; Verify that the table is usable    Iterator* iter &#x3D;        table_cache_-&gt;NewIterator(ReadOptions(), output_number, current_bytes);    s &#x3D; iter-&gt;status();    delete iter;    if (s.ok()) &#123;      Log(options_.info_log, &quot;Generated table #%llu@%d: %lld keys, %lld bytes&quot;,          (unsigned long long)output_number, compact-&gt;compaction-&gt;level(),          (unsigned long long)current_entries,          (unsigned long long)current_bytes);    &#125;  &#125;  return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件Compaction完成后，生成新的版本</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::InstallCompactionResults(CompactionState* compact) &#123;  mutex_.AssertHeld();  Log(options_.info_log, &quot;Compacted %d@%d + %d@%d files &#x3D;&gt; %lld bytes&quot;,      compact-&gt;compaction-&gt;num_input_files(0), compact-&gt;compaction-&gt;level(),      compact-&gt;compaction-&gt;num_input_files(1), compact-&gt;compaction-&gt;level() + 1,      static_cast&lt;long long&gt;(compact-&gt;total_bytes));  &#x2F;&#x2F; Add compaction outputs  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());  const int level &#x3D; compact-&gt;compaction-&gt;level();  for (size_t i &#x3D; 0; i &lt; compact-&gt;outputs.size(); i++) &#123;    const CompactionState::Output&amp; out &#x3D; compact-&gt;outputs[i];    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + 1, out.number, out.file_size,                                         out.smallest, out.largest);  &#125;  return versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/leveldb_sstable/"/>
      <url>/2022/11/24/leveldb_sstable/</url>
      
        <content type="html"><![CDATA[<p>#####SSTable<br>磁盘存储的SSTable，划分为多个Block。主要有存储数据的Block,存储索引的Block,以及为了优化查询使用的存储filter数据的block。<br>格式如下<br><img src="/../images/sstable.jpg"></p><ul><li>data block<ul><li>data block按序存储key&#x2F;value数据。一个data block 大小默认为4kb,其中key&#x2F;value 存储为entry。</li><li>为了节省空间，对连续key相同的前缀只存储前缀长度。entry格式为<code>shardkeylen,noshardkeylen,valuelen,key delta, value</code></li><li>key&#x2F;value 为变长，为了支持二分查找，同时为了避免第一个key的损坏导致整个block后续key都无法读取，默认每隔16个entry加入一个restart point。restart point 处的entry,完整存储key。在所有entry最后存储restart point 数组，二分查找时先由restart point数组定位到某个offset,然后顺序查找。<br><img src="/../images/block.png"></li></ul></li></ul><p><code>class BlockBuilder</code> 用于序列化block</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BlockBuilder &#123; public:  explicit BlockBuilder(const Options* options);  &#x2F;&#x2F; Reset the contents as if the BlockBuilder was just constructed.  void Reset();  &#x2F;&#x2F; REQUIRES: Finish() has not been called since the last call to Reset().  &#x2F;&#x2F; REQUIRES: key is larger than any previously added key  void Add(const Slice&amp; key, const Slice&amp; value);  &#x2F;&#x2F; Finish building the block and return a slice that refers to the  &#x2F;&#x2F; block contents.  The returned slice will remain valid for the  &#x2F;&#x2F; lifetime of this builder or until Reset() is called.  Slice Finish();  &#x2F;&#x2F; Returns an estimate of the current (uncompressed) size of the block  &#x2F;&#x2F; we are building.  size_t CurrentSizeEstimate() const;  &#x2F;&#x2F; Return true iff no entries have been added since the last Reset()  bool empty() const &#123; return buffer_.empty(); &#125; private:  const Options* options_;  std::string buffer_;              &#x2F;&#x2F; Destination buffer  std::vector&lt;uint32_t&gt; restarts_;  &#x2F;&#x2F; Restart points  int counter_;                     &#x2F;&#x2F; Number of entries emitted since restart  bool finished_;                   &#x2F;&#x2F; Has Finish() been called?  std::string last_key_;&#125;;Slice BlockBuilder::Finish() &#123;  &#x2F;&#x2F; Append restart array  for (size_t i &#x3D; 0; i &lt; restarts_.size(); i++) &#123;    PutFixed32(&amp;buffer_, restarts_[i]);  &#125;  PutFixed32(&amp;buffer_, restarts_.size());  finished_ &#x3D; true;  return Slice(buffer_);&#125;void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value) &#123;  Slice last_key_piece(last_key_);  assert(!finished_);  assert(counter_ &lt;&#x3D; options_-&gt;block_restart_interval);  assert(buffer_.empty()  &#x2F;&#x2F; No values yet?         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; 0);  size_t shared &#x3D; 0;  if (counter_ &lt; options_-&gt;block_restart_interval) &#123;    &#x2F;&#x2F; See how much sharing to do with previous string    const size_t min_length &#x3D; std::min(last_key_piece.size(), key.size());    while ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] &#x3D;&#x3D; key[shared])) &#123;      shared++;    &#125;  &#125; else &#123;    &#x2F;&#x2F; Restart compression    restarts_.push_back(buffer_.size());    counter_ &#x3D; 0;  &#125;  const size_t non_shared &#x3D; key.size() - shared;  &#x2F;&#x2F; Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_  PutVarint32(&amp;buffer_, shared);  PutVarint32(&amp;buffer_, non_shared);  PutVarint32(&amp;buffer_, value.size());  &#x2F;&#x2F; Add string delta to buffer_ followed by value  buffer_.append(key.data() + shared, non_shared);  buffer_.append(value.data(), value.size());  &#x2F;&#x2F; Update state  last_key_.resize(shared);  last_key_.append(key.data() + shared, non_shared);  assert(Slice(last_key_) &#x3D;&#x3D; key);  counter_++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码很直观，就不多说了。<br>block_restart_interval 可配置</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Number of keys between restart points for delta encoding of keys.&#x2F;&#x2F; This parameter can be changed dynamically.  Most clients should&#x2F;&#x2F; leave this parameter alone.int block_restart_interval &#x3D; 16;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>block size 可配置</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Approximate size of user data packed per block.  Note that the&#x2F;&#x2F; block size specified here corresponds to uncompressed data.  The&#x2F;&#x2F; actual size of the unit read from disk may be smaller if&#x2F;&#x2F; compression is enabled.  This parameter can be changed dynamically.size_t block_size &#x3D; 4 * 1024;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>class Block</code>封装了Block数据的解析操作。其data_所指向的可能为堆内存也可能为mmap映射的内存。如果为堆内存，则可被缓存，并且析构时应该delete掉。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Block &#123; public:  &#x2F;&#x2F; Initialize the block with the specified contents.  explicit Block(const BlockContents&amp; contents);  ~Block();  size_t size() const &#123; return size_; &#125;  Iterator* NewIterator(const Comparator* comparator); private:  class Iter;  uint32_t NumRestarts() const;  const char* data_;  size_t size_;  uint32_t restart_offset_;  &#x2F;&#x2F; Offset in data_ of restart array  bool owned_;               &#x2F;&#x2F; Block owns data_[]&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct BlockContents</code>为从文件读出的Block数据。文件的读取操作可能为文件io,也可能为mmap文件映射。<br>如果为mmap文件映射，则data指向的内存为映射的内存，如果为文件io，则指向堆内存。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct BlockContents &#123;  Slice data;           &#x2F;&#x2F; Actual contents of data  bool cachable;        &#x2F;&#x2F; True iff data can be cached  bool heap_allocated;  &#x2F;&#x2F; True iff caller should delete[] data.data()&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取操作由BlockHandle 设置读取的offset和偏移大小。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BlockHandle &#123; public:&#x2F;&#x2F;...... private:  uint64_t offset_;  uint64_t size_;&#125;;Status ReadBlock(RandomAccessFile* file, const ReadOptions&amp; options,                 const BlockHandle&amp; handle, BlockContents* result) &#123;  result-&gt;data &#x3D; Slice();  result-&gt;cachable &#x3D; false;  result-&gt;heap_allocated &#x3D; false;  &#x2F;&#x2F; Read the block contents as well as the type&#x2F;crc footer.  &#x2F;&#x2F; See table_builder.cc for the code that built this structure.  size_t n &#x3D; static_cast&lt;size_t&gt;(handle.size());  char* buf &#x3D; new char[n + kBlockTrailerSize];  Slice contents;  Status s &#x3D; file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);  if (!s.ok()) &#123;    delete[] buf;    return s;  &#125;  if (contents.size() !&#x3D; n + kBlockTrailerSize) &#123;    delete[] buf;    return Status::Corruption(&quot;truncated block read&quot;);  &#125;  &#x2F;&#x2F; Check the crc of the type and the block contents  const char* data &#x3D; contents.data();  &#x2F;&#x2F; Pointer to where Read put the data  if (options.verify_checksums) &#123;    const uint32_t crc &#x3D; crc32c::Unmask(DecodeFixed32(data + n + 1));    const uint32_t actual &#x3D; crc32c::Value(data, n + 1);    if (actual !&#x3D; crc) &#123;      delete[] buf;      s &#x3D; Status::Corruption(&quot;block checksum mismatch&quot;);      return s;    &#125;  &#125;  switch (data[n]) &#123;    case kNoCompression:      if (data !&#x3D; buf) &#123;        &#x2F;&#x2F; File implementation gave us pointer to some other data.        &#x2F;&#x2F; Use it directly under the assumption that it will be live        &#x2F;&#x2F; while the file is open.        delete[] buf;        result-&gt;data &#x3D; Slice(data, n);        result-&gt;heap_allocated &#x3D; false;        result-&gt;cachable &#x3D; false;  &#x2F;&#x2F; Do not double-cache      &#125; else &#123;        result-&gt;data &#x3D; Slice(buf, n);        result-&gt;heap_allocated &#x3D; true;        result-&gt;cachable &#x3D; true;      &#125;      &#x2F;&#x2F; Ok      break;    case kSnappyCompression: &#123;      size_t ulength &#x3D; 0;      if (!port::Snappy_GetUncompressedLength(data, n, &amp;ulength)) &#123;        delete[] buf;        return Status::Corruption(&quot;corrupted compressed block contents&quot;);      &#125;      char* ubuf &#x3D; new char[ulength];      if (!port::Snappy_Uncompress(data, n, ubuf)) &#123;        delete[] buf;        delete[] ubuf;        return Status::Corruption(&quot;corrupted compressed block contents&quot;);      &#125;      delete[] buf;      result-&gt;data &#x3D; Slice(ubuf, ulength);      result-&gt;heap_allocated &#x3D; true;      result-&gt;cachable &#x3D; true;      break;    &#125;    default:      delete[] buf;      return Status::Corruption(&quot;bad block type&quot;);  &#125;  return Status::OK();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后<code>class Block::Iter</code> 封装了Block中Entry的查找以及遍历操作。比较简单直接。</p><p><code>class Block</code> 以及<code>class BlockBuilder</code> 适用于DataBlock, IndexBlock的序列化和反序列化。<br>对于DataBlock,其中key为InternalKey,Value为用户存入的Value。对于IndexBlock,分为DataIndexBlock以及MetaIndexBlock。<br>DataIndexBlock中的key&gt;&#x3D;所指向的Block的最大key。Value为Block在sstable中的偏移及大小，即为BlockHandle。对于MetaIndexBlock,key只有filter Block的key,value为filter Block 的BlockHandle。<br>配置参数中<code>block_size</code> 以及<code>block_restart_interval</code>只对DataBlock有效。<br>对于IndexBlock,所有索引存储在一个Block中，不限制大小。同时block_restart_interval为1。即sharedkeylen 字段为0，key为完整的key。</p><p>######Filter Block<br>leveldb 提供的filter策略是使用bloom filter。filter block 在metaindexblock中对应的key为<br>filter策略的名字。用户也可以实现自己的策略，然后传入option即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">  if (r-&gt;filter_block !&#x3D; nullptr) &#123;    &#x2F;&#x2F; Add mapping from &quot;filter.Name&quot; to location of filter data    std::string key &#x3D; &quot;filter.&quot;;    key.append(r-&gt;options.filter_policy-&gt;Name());    std::string handle_encoding;    filter_block_handle.EncodeTo(&amp;handle_encoding);    meta_index_block.Add(key, handle_encoding);  &#125;  &#x2F;&#x2F; If non-null, use the specified filter policy to reduce disk reads.&#x2F;&#x2F; Many applications will benefit from passing the result of&#x2F;&#x2F; NewBloomFilterPolicy() here.const FilterPolicy* filter_policy &#x3D; nullptr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>class FilterBlockBuilder</code>用于创建filter block。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A FilterBlockBuilder is used to construct all of the filters for a&#x2F;&#x2F; particular Table.  It generates a single string which is stored as&#x2F;&#x2F; a special block in the Table.&#x2F;&#x2F;&#x2F;&#x2F; The sequence of calls to FilterBlockBuilder must match the regexp:&#x2F;&#x2F;      (StartBlock AddKey*)* Finishclass FilterBlockBuilder &#123; public:  explicit FilterBlockBuilder(const FilterPolicy*);  void StartBlock(uint64_t block_offset);  void AddKey(const Slice&amp; key);  Slice Finish(); private:  void GenerateFilter();  const FilterPolicy* policy_;  std::string keys_;             &#x2F;&#x2F; Flattened key contents  std::vector&lt;size_t&gt; start_;    &#x2F;&#x2F; Starting index in keys_ of each key  std::string result_;           &#x2F;&#x2F; Filter data computed so far  std::vector&lt;Slice&gt; tmp_keys_;  &#x2F;&#x2F; policy_-&gt;CreateFilter() argument  std::vector&lt;uint32_t&gt; filter_offsets_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>StartBlock</code>根据 DataBlock偏移量&#x2F;2kb 计算应该产生第几个filter string。<br><code>AddKey</code> 记录当前block中的keys。<br><code>Finish</code> 根据记录的keys生成filter string。<br>这种设计跟DataBlock大小解耦，查找时输入任意一个偏移量都能找到该偏移量所在的索引的下标。但需要保证输入的偏移量是严格递增的，keys在偏移量之后。<br>还是直接贴代码比较直观</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static const size_t kFilterBaseLg &#x3D; 11;static const size_t kFilterBase &#x3D; 1 &lt;&lt; kFilterBaseLg;void FilterBlockBuilder::StartBlock(uint64_t block_offset) &#123;  uint64_t filter_index &#x3D; (block_offset &#x2F; kFilterBase);  assert(filter_index &gt;&#x3D; filter_offsets_.size());  while (filter_index &gt; filter_offsets_.size()) &#123;    GenerateFilter();  &#125;&#125;void FilterBlockBuilder::AddKey(const Slice&amp; key) &#123;  Slice k &#x3D; key;  start_.push_back(keys_.size());  keys_.append(k.data(), k.size());&#125;Slice FilterBlockBuilder::Finish() &#123;  if (!start_.empty()) &#123;    GenerateFilter();  &#125;  &#x2F;&#x2F; Append array of per-filter offsets  const uint32_t array_offset &#x3D; result_.size();  for (size_t i &#x3D; 0; i &lt; filter_offsets_.size(); i++) &#123;    PutFixed32(&amp;result_, filter_offsets_[i]);  &#125;  PutFixed32(&amp;result_, array_offset);  result_.push_back(kFilterBaseLg);  &#x2F;&#x2F; Save encoding parameter in result  return Slice(result_);&#125;void FilterBlockBuilder::GenerateFilter() &#123;  const size_t num_keys &#x3D; start_.size();  if (num_keys &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F; Fast path if there are no keys for this filter    filter_offsets_.push_back(result_.size());    return;  &#125;  &#x2F;&#x2F; Make list of keys from flattened key structure  start_.push_back(keys_.size());  &#x2F;&#x2F; Simplify length computation  tmp_keys_.resize(num_keys);  for (size_t i &#x3D; 0; i &lt; num_keys; i++) &#123;    const char* base &#x3D; keys_.data() + start_[i];    size_t length &#x3D; start_[i + 1] - start_[i];    tmp_keys_[i] &#x3D; Slice(base, length);  &#125;  &#x2F;&#x2F; Generate filter for current set of keys and append to result_.  filter_offsets_.push_back(result_.size());  policy_-&gt;CreateFilter(&amp;tmp_keys_[0], static_cast&lt;int&gt;(num_keys), &amp;result_);  tmp_keys_.clear();  keys_.clear();  start_.clear();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用顺序严格保证为(StartBlock,AddKeys*)*Finish。</p><p><code>class FilterBlockReader</code>读取filter数据，提供检查key是否匹配接口</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class FilterBlockReader &#123; public:  &#x2F;&#x2F; REQUIRES: &quot;contents&quot; and *policy must stay live while *this is live.  FilterBlockReader(const FilterPolicy* policy, const Slice&amp; contents);  bool KeyMayMatch(uint64_t block_offset, const Slice&amp; key); private:  const FilterPolicy* policy_;  const char* data_;    &#x2F;&#x2F; Pointer to filter data (at block-start)  const char* offset_;  &#x2F;&#x2F; Pointer to beginning of offset array (at block-end)  size_t num_;          &#x2F;&#x2F; Number of entries in offset array  size_t base_lg_;      &#x2F;&#x2F; Encoding parameter (see kFilterBaseLg in .cc file)&#125;;FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,                                     const Slice&amp; contents)    : policy_(policy), data_(nullptr), offset_(nullptr), num_(0), base_lg_(0) &#123;  size_t n &#x3D; contents.size();  if (n &lt; 5) return;  &#x2F;&#x2F; 1 byte for base_lg_ and 4 for start of offset array  base_lg_ &#x3D; contents[n - 1];  uint32_t last_word &#x3D; DecodeFixed32(contents.data() + n - 5);  if (last_word &gt; n - 5) return;  data_ &#x3D; contents.data();  offset_ &#x3D; data_ + last_word;  num_ &#x3D; (n - 5 - last_word) &#x2F; 4;&#125;bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice&amp; key) &#123;  uint64_t index &#x3D; block_offset &gt;&gt; base_lg_;  if (index &lt; num_) &#123;    uint32_t start &#x3D; DecodeFixed32(offset_ + index * 4);    uint32_t limit &#x3D; DecodeFixed32(offset_ + index * 4 + 4);    if (start &lt;&#x3D; limit &amp;&amp; limit &lt;&#x3D; static_cast&lt;size_t&gt;(offset_ - data_)) &#123;      Slice filter &#x3D; Slice(data_ + start, limit - start);      return policy_-&gt;KeyMayMatch(key, filter);    &#125; else if (start &#x3D;&#x3D; limit) &#123;      &#x2F;&#x2F; Empty filters do not match any keys      return false;    &#125;  &#125;  return true;  &#x2F;&#x2F; Errors are treated as potential matches&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个简单的例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;    const leveldb::FilterPolicy* bloom_filter &#x3D; leveldb::NewBloomFilterPolicy(10);    leveldb::FilterBlockBuilder filter_block_builder(bloom_filter);    filter_block_builder.StartBlock(0);    &#x2F;&#x2F;1000 1431 1109 0002 06    filter_block_builder.AddKey(&quot;Hello&quot;);    filter_block_builder.AddKey(&quot;World&quot;);    filter_block_builder.StartBlock(3000);    &#x2F;&#x2F;2002 0043 8821 4404 06    filter_block_builder.AddKey(&quot;Go&quot;);    filter_block_builder.AddKey(&quot;Programmer&quot;);    filter_block_builder.StartBlock(20000);    &#x2F;&#x2F;1a38 64d0 c001 8300 06    filter_block_builder.AddKey(&quot;a&quot;);    filter_block_builder.AddKey(&quot;b&quot;);    filter_block_builder.AddKey(&quot;c&quot;);    leveldb::Slice result &#x3D; filter_block_builder.Finish();    leveldb::FilterBlockReader filter_block_reader(bloom_filter, result);    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(0, &quot;Hello&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(0, &quot;World&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(0, &quot;Go&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;0    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(3000, &quot;Go&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(20000, &quot;b&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;1    std::cout &lt;&lt; filter_block_reader.KeyMayMatch(20000, &quot;d&quot;) &lt;&lt; std::endl;&#x2F;&#x2F;0    delete bloom_filter;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从KeyMayMatch的结果可以看到，block_offset的指定必须要准确。<br>result的结果如图所示：<br><img src="/../images/filter.png"></p><p>当从table中读取数据时，首先需要知道索引块的位置。Footer就是记录索引块的位置。<br>Footer位于sstabl最后48字节。其中40字节为索引块的位置，最后8字节为魔术字表明这个文件是sstable。索引块为DataIndexBlock和MetaIndexBlock。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Footer encapsulates the fixed information stored at the tail&#x2F;&#x2F; end of every table file.class Footer &#123; public:  &#x2F;&#x2F; Encoded length of a Footer.  Note that the serialization of a  &#x2F;&#x2F; Footer will always occupy exactly this many bytes.  It consists  &#x2F;&#x2F; of two block handles and a magic number.  enum &#123; kEncodedLength &#x3D; 2 * BlockHandle::kMaxEncodedLength + 8 &#125;;  Footer() &#x3D; default;  &#x2F;&#x2F; The block handle for the metaindex block of the table  const BlockHandle&amp; metaindex_handle() const &#123; return metaindex_handle_; &#125;  void set_metaindex_handle(const BlockHandle&amp; h) &#123; metaindex_handle_ &#x3D; h; &#125;  &#x2F;&#x2F; The block handle for the index block of the table  const BlockHandle&amp; index_handle() const &#123; return index_handle_; &#125;  void set_index_handle(const BlockHandle&amp; h) &#123; index_handle_ &#x3D; h; &#125;  void EncodeTo(std::string* dst) const;  Status DecodeFrom(Slice* input); private:  BlockHandle metaindex_handle_;  BlockHandle index_handle_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>######SSTable<br>这样TableBuilder的设计就比较简单了，无非就是调用上述的BlockBuilder生成DataBlock,IndexBlock.调用FilterBlockBuilder生成FilterBlock.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TableBuilder::Rep &#123;  &#x2F;&#x2F;......  BlockBuilder data_block;  BlockBuilder index_block;  FilterBlockBuilder* filter_block;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>class Table</code> 读取sstable的索引信息，filter Data到内存，封装了查找数据的操作</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A Table is a sorted map from strings to strings.  Tables are&#x2F;&#x2F; immutable and persistent.  A Table may be safely accessed from&#x2F;&#x2F; multiple threads without external synchronization.class LEVELDB_EXPORT Table &#123; public:  &#x2F;&#x2F; Attempt to open the table that is stored in bytes [0..file_size)  &#x2F;&#x2F; of &quot;file&quot;, and read the metadata entries necessary to allow  &#x2F;&#x2F; retrieving data from the table.  &#x2F;&#x2F;  &#x2F;&#x2F; If successful, returns ok and sets &quot;*table&quot; to the newly opened  &#x2F;&#x2F; table.  The client should delete &quot;*table&quot; when no longer needed.  &#x2F;&#x2F; If there was an error while initializing the table, sets &quot;*table&quot;  &#x2F;&#x2F; to nullptr and returns a non-ok status.  Does not take ownership of  &#x2F;&#x2F; &quot;*source&quot;, but the client must ensure that &quot;source&quot; remains live  &#x2F;&#x2F; for the duration of the returned table&#39;s lifetime.  &#x2F;&#x2F;  &#x2F;&#x2F; *file must remain live while this Table is in use.  static Status Open(const Options&amp; options, RandomAccessFile* file,                     uint64_t file_size, Table** table);  Table(const Table&amp;) &#x3D; delete;  Table&amp; operator&#x3D;(const Table&amp;) &#x3D; delete;  ~Table();  &#x2F;&#x2F; Returns a new iterator over the table contents.  &#x2F;&#x2F; The result of NewIterator() is initially invalid (caller must  &#x2F;&#x2F; call one of the Seek methods on the iterator before using it).  Iterator* NewIterator(const ReadOptions&amp;) const;  &#x2F;&#x2F; Given a key, return an approximate byte offset in the file where  &#x2F;&#x2F; the data for that key begins (or would begin if the key were  &#x2F;&#x2F; present in the file).  The returned value is in terms of file  &#x2F;&#x2F; bytes, and so includes effects like compression of the underlying data.  &#x2F;&#x2F; E.g., the approximate offset of the last key in the table will  &#x2F;&#x2F; be close to the file length.  uint64_t ApproximateOffsetOf(const Slice&amp; key) const; private:  friend class TableCache;  struct Rep;  static Iterator* BlockReader(void*, const ReadOptions&amp;, const Slice&amp;);  explicit Table(Rep* rep) : rep_(rep) &#123;&#125;  &#x2F;&#x2F; Calls (*handle_result)(arg, ...) with the entry found after a call  &#x2F;&#x2F; to Seek(key).  May not make such a call if filter policy says  &#x2F;&#x2F; that key is not present.  Status InternalGet(const ReadOptions&amp;, const Slice&amp; key, void* arg,                     void (*handle_result)(void* arg, const Slice&amp; k,                                           const Slice&amp; v));  void ReadMeta(const Footer&amp; footer);  void ReadFilter(const Slice&amp; filter_handle_value);  Rep* const rep_;&#125;;struct Table::Rep &#123;  ~Rep() &#123;    delete filter;    delete[] filter_data;    delete index_block;  &#125;  Options options;  Status status;  RandomAccessFile* file;  uint64_t cache_id;   FilterBlockReader* filter;  const char* filter_data;  BlockHandle metaindex_handle;  &#x2F;&#x2F; Handle to metaindex_block: saved from footer  Block* index_block;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Open 函数首先读取file中的footer,解析出IndexBlockHandle 和MetaIndexBlockHandle。<br>然后读取IndexBlock块，存储指针到index_block中。Rep::cache_id 为该Table中的DataBlock被Cache时，key前8个字节。DataBlock的CacheKey由<code>Table::Req::cache_id</code> + DataBlock的大小。<br>最后调用ReadMeta读取出filter Block中的数据，存储指针到Rep::filter中。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char cache_key_buffer[16];EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);EncodeFixed64(cache_key_buffer + 8, handle.offset());Slice key(cache_key_buffer, sizeof(cache_key_buffer));cache_handle &#x3D; block_cache-&gt;Lookup(key);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status Table::Open(const Options&amp; options, RandomAccessFile* file,                   uint64_t size, Table** table) &#123;  *table &#x3D; nullptr;  if (size &lt; Footer::kEncodedLength) &#123;    return Status::Corruption(&quot;file is too short to be an sstable&quot;);  &#125;  char footer_space[Footer::kEncodedLength];  Slice footer_input;  Status s &#x3D; file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,                        &amp;footer_input, footer_space);  if (!s.ok()) return s;  Footer footer;  s &#x3D; footer.DecodeFrom(&amp;footer_input);  if (!s.ok()) return s;  &#x2F;&#x2F; Read the index block  BlockContents index_block_contents;  ReadOptions opt;  if (options.paranoid_checks) &#123;    opt.verify_checksums &#x3D; true;  &#125;  s &#x3D; ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);  if (s.ok()) &#123;    &#x2F;&#x2F; We&#39;ve successfully read the footer and the index block: we&#39;re    &#x2F;&#x2F; ready to serve requests.    Block* index_block &#x3D; new Block(index_block_contents);    Rep* rep &#x3D; new Table::Rep;    rep-&gt;options &#x3D; options;    rep-&gt;file &#x3D; file;    rep-&gt;metaindex_handle &#x3D; footer.metaindex_handle();    rep-&gt;index_block &#x3D; index_block;    rep-&gt;cache_id &#x3D; (options.block_cache ? options.block_cache-&gt;NewId() : 0);    rep-&gt;filter_data &#x3D; nullptr;    rep-&gt;filter &#x3D; nullptr;    *table &#x3D; new Table(rep);    (*table)-&gt;ReadMeta(footer);  &#125;  return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sstable的读取由二级迭代器封装了seek操作。第一级迭代器读取DataIndexBlock中的数据，定位到相应的 key-&gt;BlockHandle Entry处。第二级迭代器读取相应的DataBlock中的数据，定位到具体的key-&gt;value Entry。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Iterator* Table::NewIterator(const ReadOptions&amp; options) const &#123;  return NewTwoLevelIterator(      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),      &amp;Table::BlockReader, const_cast&lt;Table*&gt;(this), options);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TwoLevelIterator的Seek操作,首先调用一级迭代器(index_iter_)查找target，定位到某个Entry。然后初始化二级迭代器（data_iter_),最后调用二级迭代器查找target.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void TwoLevelIterator::Seek(const Slice&amp; target) &#123;  index_iter_.Seek(target);  InitDataBlock();  if (data_iter_.iter() !&#x3D; nullptr) data_iter_.Seek(target);  SkipEmptyDataBlocksForward();&#125;void TwoLevelIterator::SetDataIterator(Iterator* data_iter) &#123;  if (data_iter_.iter() !&#x3D; nullptr) SaveError(data_iter_.status());  data_iter_.Set(data_iter);&#125;void TwoLevelIterator::InitDataBlock() &#123;  if (!index_iter_.Valid()) &#123;    SetDataIterator(nullptr);  &#125; else &#123;    Slice handle &#x3D; index_iter_.value();    if (data_iter_.iter() !&#x3D; nullptr &amp;&amp;        handle.compare(data_block_handle_) &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F; data_iter_ is already constructed with this iterator, so      &#x2F;&#x2F; no need to change anything    &#125; else &#123;      Iterator* iter &#x3D; (*block_function_)(arg_, options_, handle);      data_block_handle_.assign(handle.data(), handle.size());      SetDataIterator(iter);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中初始化二级迭代器调用的是传入的Table::BlockReader函数。该函数读取Block数据，缓存到Block Cache中，最后返回该Block的迭代器。其中的缓存操作，根据ReadOption 中的fill_cache 和读出的BlockContents中的cacheable决定。如果实际的读取操作为从mmap映射中读取，则不会被cache。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Convert an index iterator value (i.e., an encoded BlockHandle)&#x2F;&#x2F; into an iterator over the contents of the corresponding block.Iterator* Table::BlockReader(void* arg, const ReadOptions&amp; options,                             const Slice&amp; index_value) &#123;  Table* table &#x3D; reinterpret_cast&lt;Table*&gt;(arg);  Cache* block_cache &#x3D; table-&gt;rep_-&gt;options.block_cache;  Block* block &#x3D; nullptr;  Cache::Handle* cache_handle &#x3D; nullptr;  BlockHandle handle;  Slice input &#x3D; index_value;  Status s &#x3D; handle.DecodeFrom(&amp;input);  &#x2F;&#x2F; We intentionally allow extra stuff in index_value so that we  &#x2F;&#x2F; can add more features in the future.  if (s.ok()) &#123;    BlockContents contents;    if (block_cache !&#x3D; nullptr) &#123;      char cache_key_buffer[16];      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);      EncodeFixed64(cache_key_buffer + 8, handle.offset());      Slice key(cache_key_buffer, sizeof(cache_key_buffer));      cache_handle &#x3D; block_cache-&gt;Lookup(key);      if (cache_handle !&#x3D; nullptr) &#123;        block &#x3D; reinterpret_cast&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));      &#125; else &#123;        s &#x3D; ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);        if (s.ok()) &#123;          block &#x3D; new Block(contents);          if (contents.cachable &amp;&amp; options.fill_cache) &#123;            cache_handle &#x3D; block_cache-&gt;Insert(key, block, block-&gt;size(),                                               &amp;DeleteCachedBlock);          &#125;        &#125;      &#125;    &#125; else &#123;      s &#x3D; ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);      if (s.ok()) &#123;        block &#x3D; new Block(contents);      &#125;    &#125;  &#125;  Iterator* iter;  if (block !&#x3D; nullptr) &#123;    iter &#x3D; block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);    if (cache_handle &#x3D;&#x3D; nullptr) &#123;      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, nullptr);    &#125; else &#123;      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);    &#125;  &#125; else &#123;    iter &#x3D; NewErrorIterator(s);  &#125;  return iter;&#125;&#x2F;&#x2F; Options that control read operationsstruct LEVELDB_EXPORT ReadOptions &#123;  ReadOptions() &#x3D; default;&#x2F;&#x2F;......  &#x2F;&#x2F; Should the data read for this iteration be cached in memory?  &#x2F;&#x2F; Callers may wish to set this field to false for bulk scans.  bool fill_cache &#x3D; true;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/leveldb_memtable/"/>
      <url>/2022/11/24/leveldb_memtable/</url>
      
        <content type="html"><![CDATA[<p>#####MemTable</p><p>######SkipList</p><ul><li><p><code>struct SkilList&lt;...&gt;::Node</code> 跳表节点，主要就是key和多层指针。leveldb支持一写多读，对跳表的写操作由互斥锁控制。既然有读写并发需要考虑并发控制问题，因为leveldb对跳表的写操作只有添加节点，也就是只对添加节点前后的指针做修改，同时读写操作，写由底层向上层修改，读操作由顶层向下读。那在添加节点时，控制好指针修改顺序，对指针的访问，如果实际代码的执行能跟程序期望的一样，那就不需要互斥锁了。leveldb 使用了std::atomic 和memory order 这两个c++11的新特性，实现了lock_free的跳跃表。相比于使用操作系统提供的锁操作，性能要高不少。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename Key, class Comparator&gt;struct SkipList&lt;Key, Comparator&gt;::Node &#123;  explicit Node(const Key&amp; k) : key(k) &#123;&#125;  Key const key;  Node* Next(int n) &#123;    assert(n &gt;&#x3D; 0);    return next_[n].load(std::memory_order_acquire);  &#125;  void SetNext(int n, Node* x) &#123;    assert(n &gt;&#x3D; 0);    next_[n].store(x, std::memory_order_release);  &#125;  Node* NoBarrier_Next(int n) &#123;    assert(n &gt;&#x3D; 0);    return next_[n].load(std::memory_order_relaxed);  &#125;  void NoBarrier_SetNext(int n, Node* x) &#123;    assert(n &gt;&#x3D; 0);    next_[n].store(x, std::memory_order_relaxed);  &#125; private:  std::atomic&lt;Node*&gt; next_[1];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>template&lt;typename key, class Comparator&gt; class SkipList</code> 主要需要支持访问和插入操作。访问操作由内嵌的Iterator 实现。插入操作会修改<code>max_height_</code>成员，只需要保证原子性，而对读操作如果读到修改前的值，并没有影响。只要保证读操作一旦读到链表修改后的指针，后续读到的链表是已经修改完成了的链表。<code>head_</code>会初始化<code>kMaxHeight</code>层指针。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename Key, class Comparator&gt;class SkipList &#123; private:  struct Node; public:  &#x2F;&#x2F; Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,  &#x2F;&#x2F; and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena  &#x2F;&#x2F; must remain allocated for the lifetime of the skiplist object.  explicit SkipList(Comparator cmp, Arena* arena);&#x2F;&#x2F;......  &#x2F;&#x2F; Insert key into the list.  &#x2F;&#x2F; REQUIRES: nothing that compares equal to key is currently in the list.  void Insert(const Key&amp; key);    &#x2F;&#x2F; Iteration over the contents of a skip list  class Iterator &#123;&#125;; private:  enum &#123; kMaxHeight &#x3D; 12 &#125;;  &#x2F;&#x2F; Immutable after construction  Comparator const compare_;  Arena* const arena_;  &#x2F;&#x2F; Arena used for allocations of nodes  Node* const head_;  &#x2F;&#x2F; Modified only by Insert().  Read racily by readers, but stale  &#x2F;&#x2F; values are ok.  std::atomic&lt;int&gt; max_height_;  &#x2F;&#x2F; Height of the entire list  &#x2F;&#x2F; Read&#x2F;written only by Insert().  Random rnd_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键在于insert时，链表的修改由底层向上，同时每层链表，先修改next指向插入后节点，在 release_store prev节点的next指针</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename Key, class Comparator&gt;void SkipList&lt;Key, Comparator&gt;::Insert(const Key&amp; key) &#123;  &#x2F;&#x2F; TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()  &#x2F;&#x2F; here since Insert() is externally synchronized.  Node* prev[kMaxHeight];  Node* x &#x3D; FindGreaterOrEqual(key, prev);  &#x2F;&#x2F; Our data structure does not allow duplicate insertion  assert(x &#x3D;&#x3D; nullptr || !Equal(key, x-&gt;key));  int height &#x3D; RandomHeight();  if (height &gt; GetMaxHeight()) &#123;    for (int i &#x3D; GetMaxHeight(); i &lt; height; i++) &#123;      prev[i] &#x3D; head_;    &#125;    &#x2F;&#x2F; It is ok to mutate max_height_ without any synchronization    &#x2F;&#x2F; with concurrent readers.  A concurrent reader that observes    &#x2F;&#x2F; the new value of max_height_ will see either the old value of    &#x2F;&#x2F; new level pointers from head_ (nullptr), or a new value set in    &#x2F;&#x2F; the loop below.  In the former case the reader will    &#x2F;&#x2F; immediately drop to the next level since nullptr sorts after all    &#x2F;&#x2F; keys.  In the latter case the reader will use the new node.    max_height_.store(height, std::memory_order_relaxed);  &#125;  x &#x3D; NewNode(key, height);  for (int i &#x3D; 0; i &lt; height; i++) &#123;    &#x2F;&#x2F; NoBarrier_SetNext() suffices since we will add a barrier when    &#x2F;&#x2F; we publish a pointer to &quot;x&quot; in prev[i].    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));    prev[i]-&gt;SetNext(i, x);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>class Iterator</code>主要就是封装了skipList的遍历操作，使用时需要先定位到某个Node。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Iteration over the contents of a skip list  class Iterator &#123;   public:    &#x2F;&#x2F; Initialize an iterator over the specified list.    &#x2F;&#x2F; The returned iterator is not valid.    explicit Iterator(const SkipList* list);    &#x2F;&#x2F; Returns true iff the iterator is positioned at a valid node.    bool Valid() const;    &#x2F;&#x2F; Returns the key at the current position.    &#x2F;&#x2F; REQUIRES: Valid()    const Key&amp; key() const;    &#x2F;&#x2F; Advances to the next position.    &#x2F;&#x2F; REQUIRES: Valid()    void Next();    &#x2F;&#x2F; Advances to the previous position.    &#x2F;&#x2F; REQUIRES: Valid()    void Prev();    &#x2F;&#x2F; Advance to the first entry with a key &gt;&#x3D; target    void Seek(const Key&amp; target);    &#x2F;&#x2F; Position at the first entry in list.    &#x2F;&#x2F; Final state of iterator is Valid() iff list is not empty.    void SeekToFirst();    &#x2F;&#x2F; Position at the last entry in list.    &#x2F;&#x2F; Final state of iterator is Valid() iff list is not empty.    void SeekToLast();   private:    const SkipList* list_;    Node* node_;    &#x2F;&#x2F; Intentionally copyable  &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>skiplist 每个节点的高度以1&#x2F;4的概率向上层增长。每个节点的高度的概率期望为<br><code>1*(1-p) + 2*p*(1-p) + 3*p*p*(1-p)... = 1/(1-p)</code>。当p为1&#x2F;4时，平均每个节点1.33个指针。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename Key, class Comparator&gt;int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;  &#x2F;&#x2F; Increase height with probability 1 in kBranching  static const unsigned int kBranching &#x3D; 4;  int height &#x3D; 1;  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) &#x3D;&#x3D; 0)) &#123;    height++;  &#125;  assert(height &gt; 0);  assert(height &lt;&#x3D; kMaxHeight);  return height;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找平均时间复杂度为O(logn)，计算比较复杂。</p><ul><li><p>模板参数<code>Key</code> 为<code>const char*</code>,实际指向由<code>InternalKeySize + InternalKey + ValueSize + Value</code> 组成buf。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MemTable::Add(SequenceNumber s, ValueType type, const Slice&amp; key,                   const Slice&amp; value) &#123;  &#x2F;&#x2F; Format of an entry is concatenation of:  &#x2F;&#x2F;  key_size     : varint32 of internal_key.size()  &#x2F;&#x2F;  key bytes    : char[internal_key.size()]  &#x2F;&#x2F;  value_size   : varint32 of value.size()  &#x2F;&#x2F;  value bytes  : char[value.size()]  size_t key_size &#x3D; key.size();  size_t val_size &#x3D; value.size();  size_t internal_key_size &#x3D; key_size + 8;  const size_t encoded_len &#x3D; VarintLength(internal_key_size) +                             internal_key_size + VarintLength(val_size) +                             val_size;  char* buf &#x3D; arena_.Allocate(encoded_len);  char* p &#x3D; EncodeVarint32(buf, internal_key_size);  std::memcpy(p, key.data(), key_size);  p +&#x3D; key_size;  EncodeFixed64(p, (s &lt;&lt; 8) | type);  p +&#x3D; 8;  p &#x3D; EncodeVarint32(p, val_size);  std::memcpy(p, value.data(), val_size);  assert(p + val_size &#x3D;&#x3D; buf + encoded_len);  table_.Insert(buf);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中长度字段变长编码，即不是固定字节数表示长度，而是对于所使用的字节，首位bit为1表示未结束，首位bit为0表示已结束。所有整数字段均使用小端存储。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* EncodeVarint32(char* dst, uint32_t v) &#123;  &#x2F;&#x2F; Operate on characters as unsigneds  uint8_t* ptr &#x3D; reinterpret_cast&lt;uint8_t*&gt;(dst);  static const int B &#x3D; 128;  if (v &lt; (1 &lt;&lt; 7)) &#123;    *(ptr++) &#x3D; v;  &#125; else if (v &lt; (1 &lt;&lt; 14)) &#123;    *(ptr++) &#x3D; v | B;    *(ptr++) &#x3D; v &gt;&gt; 7;  &#125; else if (v &lt; (1 &lt;&lt; 21)) &#123;    *(ptr++) &#x3D; v | B;    *(ptr++) &#x3D; (v &gt;&gt; 7) | B;    *(ptr++) &#x3D; v &gt;&gt; 14;  &#125; else if (v &lt; (1 &lt;&lt; 28)) &#123;    *(ptr++) &#x3D; v | B;    *(ptr++) &#x3D; (v &gt;&gt; 7) | B;    *(ptr++) &#x3D; (v &gt;&gt; 14) | B;    *(ptr++) &#x3D; v &gt;&gt; 21;  &#125; else &#123;    *(ptr++) &#x3D; v | B;    *(ptr++) &#x3D; (v &gt;&gt; 7) | B;    *(ptr++) &#x3D; (v &gt;&gt; 14) | B;    *(ptr++) &#x3D; (v &gt;&gt; 21) | B;    *(ptr++) &#x3D; v &gt;&gt; 28;  &#125;  return reinterpret_cast&lt;char*&gt;(ptr);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>InternalKey 由user_key,sequence,valuetype组成。sequence为每次写操作自增的序列号。<br>valuetype区分是否为删除key。其中sequence 56bit,valuetype占用一个字节。<br>InternalKey字段，Value字段最长为2的32次方，即4MB,所以leveldb 的key,value也不是不限制长度的。过长的Key,Value在Add时候会直接assert失败。</p></li><li><p>模板参数<code>Comparator</code> 默认字节序比较user key。user key相同时，按照sequence逆序比较。sequence越大的越在前，即新版本覆盖旧版本。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int InternalKeyComparator::Compare(const Slice&amp; akey, const Slice&amp; bkey) const &#123;  &#x2F;&#x2F; Order by:  &#x2F;&#x2F;    increasing user key (according to user-supplied comparator)  &#x2F;&#x2F;    decreasing sequence number  &#x2F;&#x2F;    decreasing type (though sequence# should be enough to disambiguate)  int r &#x3D; user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));  if (r &#x3D;&#x3D; 0) &#123;    const uint64_t anum &#x3D; DecodeFixed64(akey.data() + akey.size() - 8);    const uint64_t bnum &#x3D; DecodeFixed64(bkey.data() + bkey.size() - 8);    if (anum &gt; bnum) &#123;      r &#x3D; -1;    &#125; else if (anum &lt; bnum) &#123;      r &#x3D; +1;    &#125;  &#125;  return r;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时user key 的比较操作用户可自己实现定制版本参入option即可。</p></li></ul><p>######MemTable</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MemTable &#123; public:  &#x2F;&#x2F; MemTables are reference counted.  The initial reference count  &#x2F;&#x2F; is zero and the caller must call Ref() at least once.  explicit MemTable(const InternalKeyComparator&amp; comparator);  &#x2F;&#x2F; Increase reference count.  void Ref() &#123; ++refs_; &#125;  &#x2F;&#x2F; Drop reference count.  Delete if no more references exist.  void Unref() &#123;    --refs_;    assert(refs_ &gt;&#x3D; 0);    if (refs_ &lt;&#x3D; 0) &#123;      delete this;    &#125;  &#125;  &#x2F;&#x2F; Returns an estimate of the number of bytes of data in use by this  &#x2F;&#x2F; data structure. It is safe to call when MemTable is being modified.  size_t ApproximateMemoryUsage();  &#x2F;&#x2F; Return an iterator that yields the contents of the memtable.  &#x2F;&#x2F;  &#x2F;&#x2F; The caller must ensure that the underlying MemTable remains live  &#x2F;&#x2F; while the returned iterator is live.  The keys returned by this  &#x2F;&#x2F; iterator are internal keys encoded by AppendInternalKey in the  &#x2F;&#x2F; db&#x2F;format.&#123;h,cc&#125; module.  Iterator* NewIterator();  &#x2F;&#x2F; Add an entry into memtable that maps key to value at the  &#x2F;&#x2F; specified sequence number and with the specified type.  &#x2F;&#x2F; Typically value will be empty if type&#x3D;&#x3D;kTypeDeletion.  void Add(SequenceNumber seq, ValueType type, const Slice&amp; key,           const Slice&amp; value);  &#x2F;&#x2F; If memtable contains a value for key, store it in *value and return true.  &#x2F;&#x2F; If memtable contains a deletion for key, store a NotFound() error  &#x2F;&#x2F; in *status and return true.  &#x2F;&#x2F; Else, return false.  bool Get(const LookupKey&amp; key, std::string* value, Status* s); private:  friend class MemTableIterator;  friend class MemTableBackwardIterator;  struct KeyComparator &#123;    const InternalKeyComparator comparator;    explicit KeyComparator(const InternalKeyComparator&amp; c) : comparator(c) &#123;&#125;    int operator()(const char* a, const char* b) const;  &#125;;  typedef SkipList&lt;const char*, KeyComparator&gt; Table;  ~MemTable();  &#x2F;&#x2F; Private since only Unref() should be used to delete it  KeyComparator comparator_;  int refs_;  Arena arena_;  Table table_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>底层SkipList存储的Key为const char* ,MemTable封装了SkipList，当添加key&#x2F;value时，分配内存，序列化key&#x2F;value为内部存储的格式，插入SkipList。SkipList 中 Node 的分配也为heap 内存。MemTable为引用计数对象，当计数为0时释放内存。</p><p>实际内存的分配释放均由Arena实现</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;Node 内存分配template &lt;typename Key, class Comparator&gt;typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(    const Key&amp; key, int height) &#123;  char* const node_memory &#x3D; arena_-&gt;AllocateAligned(      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1));  return new (node_memory) Node(key);&#125;&#x2F;&#x2F;key&#x2F;value 内存分配&#96;size_t key_size &#x3D; key.size();  size_t val_size &#x3D; value.size();  size_t internal_key_size &#x3D; key_size + 8;  const size_t encoded_len &#x3D; VarintLength(internal_key_size) +                             internal_key_size + VarintLength(val_size) +                             val_size;  char* buf &#x3D; arena_.Allocate(encoded_len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Arena 实现了一个简单的内存池，避免频繁调用new分配小内存。内存释放在MemTable引用计数为0时一次性释放。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Arena &#123; public:  Arena();  ~Arena();  &#x2F;&#x2F; Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.  char* Allocate(size_t bytes);  &#x2F;&#x2F; Allocate memory with the normal alignment guarantees provided by malloc.  char* AllocateAligned(size_t bytes);  &#x2F;&#x2F; Returns an estimate of the total memory usage of data allocated  &#x2F;&#x2F; by the arena.  size_t MemoryUsage() const &#123;    return memory_usage_.load(std::memory_order_relaxed);  &#125; private:  char* AllocateFallback(size_t bytes);  char* AllocateNewBlock(size_t block_bytes);  &#x2F;&#x2F; Allocation state  char* alloc_ptr_;  size_t alloc_bytes_remaining_;  &#x2F;&#x2F; Array of new[] allocated memory blocks  std::vector&lt;char*&gt; blocks_;  &#x2F;&#x2F; Total memory usage of the arena.  std::atomic&lt;size_t&gt; memory_usage_;&#125;;static const int kBlockSize &#x3D; 4096;Arena::Arena()    : alloc_ptr_(nullptr), alloc_bytes_remaining_(0), memory_usage_(0) &#123;&#125;Arena::~Arena() &#123;  for (size_t i &#x3D; 0; i &lt; blocks_.size(); i++) &#123;    delete[] blocks_[i];  &#125;&#125;inline char* Arena::Allocate(size_t bytes) &#123;  assert(bytes &gt; 0);  if (bytes &lt;&#x3D; alloc_bytes_remaining_) &#123;    char* result &#x3D; alloc_ptr_;    alloc_ptr_ +&#x3D; bytes;    alloc_bytes_remaining_ -&#x3D; bytes;    return result;  &#125;  return AllocateFallback(bytes);&#125;char* Arena::AllocateFallback(size_t bytes) &#123;  if (bytes &gt; kBlockSize &#x2F; 4) &#123;    &#x2F;&#x2F; Object is more than a quarter of our block size.  Allocate it separately    &#x2F;&#x2F; to avoid wasting too much space in leftover bytes.    char* result &#x3D; AllocateNewBlock(bytes);    return result;  &#125;  &#x2F;&#x2F; We waste the remaining space in the current block.  alloc_ptr_ &#x3D; AllocateNewBlock(kBlockSize);  alloc_bytes_remaining_ &#x3D; kBlockSize;  char* result &#x3D; alloc_ptr_;  alloc_ptr_ +&#x3D; bytes;  alloc_bytes_remaining_ -&#x3D; bytes;  return result;&#125;char* Arena::AllocateNewBlock(size_t block_bytes) &#123;  char* result &#x3D; new char[block_bytes];  blocks_.push_back(result);  memory_usage_.fetch_add(block_bytes + sizeof(char*),                          std::memory_order_relaxed);  return result;&#125;char* Arena::AllocateAligned(size_t bytes) &#123;  const int align &#x3D; (sizeof(void*) &gt; 8) ? sizeof(void*) : 8;  static_assert((align &amp; (align - 1)) &#x3D;&#x3D; 0,                &quot;Pointer size should be a power of 2&quot;);  size_t current_mod &#x3D; reinterpret_cast&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align - 1);  size_t slop &#x3D; (current_mod &#x3D;&#x3D; 0 ? 0 : align - current_mod);  size_t needed &#x3D; bytes + slop;  char* result;  if (needed &lt;&#x3D; alloc_bytes_remaining_) &#123;    result &#x3D; alloc_ptr_ + slop;    alloc_ptr_ +&#x3D; needed;    alloc_bytes_remaining_ -&#x3D; needed;  &#125; else &#123;    &#x2F;&#x2F; AllocateFallback always returned aligned memory    result &#x3D; AllocateFallback(bytes);  &#125;  assert((reinterpret_cast&lt;uintptr_t&gt;(result) &amp; (align - 1)) &#x3D;&#x3D; 0);  return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现非常简洁了，内存池中一块大小默认为4KB,分配内存时，如果当前块剩余空间够用直接分配，如果不够用，根据所需空间大小，如果大于1&#x2F;4块空间，则直接分配所需空间，否则分配一个整块内存。<br>new出来的内存块默认都是内存对齐的。如果是在内存池中分配的内存，内存对齐时需要格外计算padding字节数。Node空间的分配需要内存对齐，提高对SkipList遍历的速度。</p><p>leveldb 对内存空间的使用，一个是MemTable的使用，一个是对sstable元数据，block块数据的LRUCache。<br>其中MemTable的默认为4MB大小。当MemTable满了后，不能再写入，需要转为immutable MemTable。同时new 一个新的MemTable。<br>如果已经有immutable MemTable存在，需要等immutable MemTable compaction 压缩为level0 sstable 完成。<br>故而内存中最多有两个MemTable。MemTable 大小可配置。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Amount of data to build up in memory (backed by an unsorted log&#x2F;&#x2F; on disk) before converting to a sorted on-disk file.&#x2F;&#x2F;&#x2F;&#x2F; Larger values increase performance, especially during bulk loads.&#x2F;&#x2F; Up to two write buffers may be held in memory at the same time,&#x2F;&#x2F; so you may wish to adjust this parameter to control memory usage.&#x2F;&#x2F; Also, a larger write buffer will result in a longer recovery time&#x2F;&#x2F; the next time the database is opened.size_t write_buffer_size &#x3D; 4 * 1024 * 1024;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MemTable还是比较简洁直观的，一个非常值得学习的点就是lock_free的SkipList。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/leveldb_compaction/"/>
      <url>/2022/11/24/leveldb_compaction/</url>
      
        <content type="html"><![CDATA[<p>leveldb的compaction 分为immutable memtable compaction 为Level0的sstable, leveln 和leveln+1 层sstables文件之前的compaction。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/levedb_cache/"/>
      <url>/2022/11/24/levedb_cache/</url>
      
        <content type="html"><![CDATA[<p>######LRUCache<br>leveldb 的Cache分为Block Cache 和Table Cache,默认都是使用的LRUCache</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Worldta</title>
      <link href="/2022/11/23/hello-world/"/>
      <url>/2022/11/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h4 id="Test-Images"><a href="#Test-Images" class="headerlink" title="Test Images"></a>Test Images</h4><p><img src="/../images/lkd/lkd-10.png"></p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@node1:~/test-go-module<span class="token comment"># go test</span>go: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
